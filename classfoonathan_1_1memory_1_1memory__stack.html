<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: memory_stack&lt; BlockOrRawAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html">memory_stack</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-static-methods">Static Functions</a> &#124;
<a href="#pub-methods">Member Functions</a>  </div>
  <div class="headertitle"><div class="title">memory_stack&lt; BlockOrRawAllocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__allocator.html">Allocator implementations</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class BlockOrRawAllocator = default_allocator&gt;<br />
class foonathan::memory::memory_stack&lt; BlockOrRawAllocator &gt;</div><p>A stateful <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> that provides stack-like (LIFO) allocations. </p>
<p>It uses a <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> with a given <code>BlockOrRawAllocator</code> defaulting to <a class="el" href="classfoonathan_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a> to allocate huge blocks and saves a marker to the current top. Allocation simply moves this marker by the appropriate number of bytes and returns the pointer at the old marker position, deallocation is not directly supported, only setting the marker to a previously queried position. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7fd26a8539389ffa2a4b1d1a7b6b839c" id="r_a7fd26a8539389ffa2a4b1d1a7b6b839c"><td class="memItemLeft" align="right" valign="top"><a id="a7fd26a8539389ffa2a4b1d1a7b6b839c" name="a7fd26a8539389ffa2a4b1d1a7b6b839c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a7fd26a8539389ffa2a4b1d1a7b6b839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbad424c0f47dace6b20e93164d7c1c0" id="r_afbad424c0f47dace6b20e93164d7c1c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbad424c0f47dace6b20e93164d7c1c0">marker</a></td></tr>
<tr class="memdesc:afbad424c0f47dace6b20e93164d7c1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The marker type that is used for unwinding.  <br /></td></tr>
<tr class="separator:afbad424c0f47dace6b20e93164d7c1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Functions</h2></td></tr>
<tr class="memitem:abb8ad90ad0272471cc42cf1bb3f50bc1" id="r_abb8ad90ad0272471cc42cf1bb3f50bc1"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb8ad90ad0272471cc42cf1bb3f50bc1">min_block_size</a> (std::size_t byte_size) noexcept</td></tr>
<tr class="separator:abb8ad90ad0272471cc42cf1bb3f50bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:ab31c164183f69bc08896cfc4a8e5e8e7" id="r_ab31c164183f69bc08896cfc4a8e5e8e7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab31c164183f69bc08896cfc4a8e5e8e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab31c164183f69bc08896cfc4a8e5e8e7">memory_stack</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab31c164183f69bc08896cfc4a8e5e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4c2a859f70fa94dd453cfdcffe334d" id="r_a9f4c2a859f70fa94dd453cfdcffe334d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f4c2a859f70fa94dd453cfdcffe334d">allocate</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a9f4c2a859f70fa94dd453cfdcffe334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13eb887dbe32ff1ee5ffe45fdcd46aa" id="r_ac13eb887dbe32ff1ee5ffe45fdcd46aa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac13eb887dbe32ff1ee5ffe45fdcd46aa">try_allocate</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:ac13eb887dbe32ff1ee5ffe45fdcd46aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe61fb94b49aa0aaaadd752f052adbe" id="r_aefe61fb94b49aa0aaaadd752f052adbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#afbad424c0f47dace6b20e93164d7c1c0">marker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefe61fb94b49aa0aaaadd752f052adbe">top</a> () const noexcept</td></tr>
<tr class="separator:aefe61fb94b49aa0aaaadd752f052adbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f30af46c3d77066c680388109be2321" id="r_a9f30af46c3d77066c680388109be2321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f30af46c3d77066c680388109be2321">unwind</a> (<a class="el" href="#afbad424c0f47dace6b20e93164d7c1c0">marker</a> m) noexcept</td></tr>
<tr class="separator:a9f30af46c3d77066c680388109be2321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4af5032d71179d3abf04db463f791" id="r_ad9e4af5032d71179d3abf04db463f791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit</a> () noexcept</td></tr>
<tr class="separator:ad9e4af5032d71179d3abf04db463f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da77ca5a46e5e3088d6c0637b52af7" id="r_a97da77ca5a46e5e3088d6c0637b52af7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97da77ca5a46e5e3088d6c0637b52af7">capacity_left</a> () const noexcept</td></tr>
<tr class="separator:a97da77ca5a46e5e3088d6c0637b52af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe037332aabd13253517d22394da73" id="r_af4fe037332aabd13253517d22394da73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4fe037332aabd13253517d22394da73">next_capacity</a> () const noexcept</td></tr>
<tr class="separator:af4fe037332aabd13253517d22394da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b7646357aaf9599f36aa528674aaa" id="r_acf4b7646357aaf9599f36aa528674aaa"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4b7646357aaf9599f36aa528674aaa">get_allocator</a> () noexcept</td></tr>
<tr class="separator:acf4b7646357aaf9599f36aa528674aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedefs</h2>
<a id="afbad424c0f47dace6b20e93164d7c1c0" name="afbad424c0f47dace6b20e93164d7c1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbad424c0f47dace6b20e93164d7c1c0">&#9670;&#160;</a></span>marker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afbad424c0f47dace6b20e93164d7c1c0">marker</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The marker type that is used for unwinding. </p>
<p>The exact type is implementation defined, it is only required that it is efficiently copyable and has all the comparision operators defined for two markers on the same stack. Two markers are equal, if they are copies or created from two <code>top()</code> calls without a call to <code>unwind()</code> or <code>allocate()</code>. A marker <code>a</code> is less than marker <code>b</code>, if after <code>a</code> was obtained, there was one or more call to <code>allocate()</code> and no call to <code>unwind()</code>. </p>

</div>
</div>
<h2 class="groupheader">Constructors</h2>
<a id="ab31c164183f69bc08896cfc4a8e5e8e7" name="ab31c164183f69bc08896cfc4a8e5e8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31c164183f69bc08896cfc4a8e5e8e7">&#9670;&#160;</a></span>memory_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html">memory_stack</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates it with a given initial block size and and other constructor arguments for the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. It will allocate the first block and sets the top to its beginning. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>block_size</code> must be at least <code>min_block_size(1)</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Functions</h2>
<a id="abb8ad90ad0272471cc42cf1bb3f50bc1" name="abb8ad90ad0272471cc42cf1bb3f50bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8ad90ad0272471cc42cf1bb3f50bc1">&#9670;&#160;</a></span>min_block_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t min_block_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>byte_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The minimum block size required for a stack containing the given amount of memory. If a stack is created with the result of <code>min_block_size(n)</code>, the resulting capacity will be exactly <code>n</code>. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>byte_size</code> must be a positive number. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to debug fence sizes, the actual amount of usable memory can vary. However, this is impossible to compute without knowing the exact allocation pattern before, so this is just a rough estimate. </dd></dl>

</div>
</div>
<a id="a9f4c2a859f70fa94dd453cfdcffe334d" name="a9f4c2a859f70fa94dd453cfdcffe334d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4c2a859f70fa94dd453cfdcffe334d">&#9670;&#160;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates a memory block of given size and alignment. It simply moves the top marker. If there is not enough space on the current memory block, a new one will be allocated by the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> or taken from a cache and used for the allocation. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>A <a href="md_doc_concepts.html#concept_node">node</a> with given size and alignment. </dd></dl>
<dl class="section user"><dt><em>Throws:</em></dt><dd>Anything thrown by the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> on growth or <a class="el" href="classfoonathan_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a> if <code>size</code> is too big. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>size</code> and <code>alignment</code> must be valid. </dd></dl>

</div>
</div>
<a id="ac13eb887dbe32ff1ee5ffe45fdcd46aa" name="ac13eb887dbe32ff1ee5ffe45fdcd46aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13eb887dbe32ff1ee5ffe45fdcd46aa">&#9670;&#160;</a></span>try_allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * try_allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates a memory block of given size and alignment, similar to <a class="el" href="#a9f4c2a859f70fa94dd453cfdcffe334d">allocate()</a>. But it does not attempt a growth if the arena is empty. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>A <a href="md_doc_concepts.html#concept_node">node</a> with given size and alignment or <code>nullptr</code> if there wasn't enough memory available. </dd></dl>

</div>
</div>
<a id="aefe61fb94b49aa0aaaadd752f052adbe" name="aefe61fb94b49aa0aaaadd752f052adbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe61fb94b49aa0aaaadd752f052adbe">&#9670;&#160;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afbad424c0f47dace6b20e93164d7c1c0">marker</a> top </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A marker to the current top of the stack. </dd></dl>

</div>
</div>
<a id="a9f30af46c3d77066c680388109be2321" name="a9f30af46c3d77066c680388109be2321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f30af46c3d77066c680388109be2321">&#9670;&#160;</a></span>unwind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unwind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#afbad424c0f47dace6b20e93164d7c1c0">marker</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Unwinds the stack to a certain marker position. This sets the top pointer of the stack to the position described by the marker and has the effect of deallocating all memory allocated since the marker was obtained. If any memory blocks are unused after the operation, they are not deallocated but put in a cache for later use, call <a class="el" href="#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit()</a> to actually deallocate them. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The marker must point to memory that is still in use and was the whole time, i.e. it must have been pointed below the top at all time. </dd></dl>

</div>
</div>
<a id="ad9e4af5032d71179d3abf04db463f791" name="ad9e4af5032d71179d3abf04db463f791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4af5032d71179d3abf04db463f791">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd><a class="el" href="#a9f30af46c3d77066c680388109be2321">unwind()</a> does not actually do any deallocation of blocks on the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>, unused memory is stored in a cache for later reuse. This function clears that cache. </dd></dl>

</div>
</div>
<a id="a97da77ca5a46e5e3088d6c0637b52af7" name="a97da77ca5a46e5e3088d6c0637b52af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97da77ca5a46e5e3088d6c0637b52af7">&#9670;&#160;</a></span>capacity_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t capacity_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The amount of memory remaining in the current block. This is the number of bytes that are available for allocation before the cache or <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> needs to be used. </dd></dl>

</div>
</div>
<a id="af4fe037332aabd13253517d22394da73" name="af4fe037332aabd13253517d22394da73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fe037332aabd13253517d22394da73">&#9670;&#160;</a></span>next_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t next_capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The size of the next memory block after the current block is exhausted and the arena grows. This function just forwards to the <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All of it is available for the stack to use, but due to fences and alignment buffers, this may not be the exact amount of memory usable for the user. </dd></dl>

</div>
</div>
<a id="acf4b7646357aaf9599f36aa528674aaa" name="acf4b7646357aaf9599f36aa528674aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4b7646357aaf9599f36aa528674aaa">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator = default_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type &amp; get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A reference to the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> used for managing the arena. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>It is undefined behavior to move this allocator out into another object. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2
</small></address>
</body>
</html>
