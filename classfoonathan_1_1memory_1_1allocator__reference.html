<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: allocator_reference&lt; RawAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-methods">Member Functions</a> &#124;
<a href="#related">Related Symbols</a>  </div>
  <div class="headertitle"><div class="title">allocator_reference&lt; RawAllocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__storage.html">Allocator storage</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class RawAllocator&gt;<br />
class foonathan::memory::allocator_reference&lt; RawAllocator &gt;</div><p>An alias template for <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> using the <a class="el" href="classfoonathan_1_1memory_1_1reference__storage.html">reference_storage</a> policy. </p>
<p>It will store a reference to the given allocator type. The tag type <a class="el" href="structfoonathan_1_1memory_1_1any__allocator.html">any_allocator</a> enables type-erasure. Wrap the allocator in a <a class="el" href="classfoonathan_1_1memory_1_1thread__safe__allocator.html">thread_safe_allocator</a> if you want thread safety. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd368539d4750dc2ea909343eed521b2" id="r_abd368539d4750dc2ea909343eed521b2"><td class="memItemLeft" align="right" valign="top"><a id="abd368539d4750dc2ea909343eed521b2" name="abd368539d4750dc2ea909343eed521b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:abd368539d4750dc2ea909343eed521b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9615e22334e493ec6ef1f8588966cb2c" id="r_a9615e22334e493ec6ef1f8588966cb2c"><td class="memItemLeft" align="right" valign="top"><a id="a9615e22334e493ec6ef1f8588966cb2c" name="a9615e22334e493ec6ef1f8588966cb2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>storage_policy</b></td></tr>
<tr class="separator:a9615e22334e493ec6ef1f8588966cb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a0dfdee0c83539ff9725f255c81ef" id="r_a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memItemLeft" align="right" valign="top"><a id="a4a7a0dfdee0c83539ff9725f255c81ef" name="a4a7a0dfdee0c83539ff9725f255c81ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="separator:a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf829738ba45a0c47d96f529154baf0" id="r_aecf829738ba45a0c47d96f529154baf0"><td class="memItemLeft" align="right" valign="top"><a id="aecf829738ba45a0c47d96f529154baf0" name="aecf829738ba45a0c47d96f529154baf0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>is_stateful</b></td></tr>
<tr class="separator:aecf829738ba45a0c47d96f529154baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:ac9c64316bb7697bc5b3cc48328369218" id="r_ac9c64316bb7697bc5b3cc48328369218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable</a> () const noexcept</td></tr>
<tr class="separator:ac9c64316bb7697bc5b3cc48328369218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab8b151450b913fc7140ace3938ffbb58" id="r_ab8b151450b913fc7140ace3938ffbb58"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ab8b151450b913fc7140ace3938ffbb58">allocate_node</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:ab8b151450b913fc7140ace3938ffbb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757c28e5045efdd84d5c14de84e284ef" id="r_a757c28e5045efdd84d5c14de84e284ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a757c28e5045efdd84d5c14de84e284ef">allocate_array</a> (std::size_t count, std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a757c28e5045efdd84d5c14de84e284ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c4c8201ed3a86738d5571239e19db" id="r_af39c4c8201ed3a86738d5571239e19db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#af39c4c8201ed3a86738d5571239e19db">deallocate_node</a> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:af39c4c8201ed3a86738d5571239e19db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f89da0a2dbd6ad5089178c828bb95df" id="r_a7f89da0a2dbd6ad5089178c828bb95df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a7f89da0a2dbd6ad5089178c828bb95df">deallocate_array</a> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a7f89da0a2dbd6ad5089178c828bb95df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64caa0912affaefd4778635a8a76294c" id="r_a64caa0912affaefd4778635a8a76294c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a64caa0912affaefd4778635a8a76294c">max_node_size</a> () const</td></tr>
<tr class="separator:a64caa0912affaefd4778635a8a76294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f877acb00d33a3725a41c767152a5c" id="r_a62f877acb00d33a3725a41c767152a5c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a62f877acb00d33a3725a41c767152a5c">max_array_size</a> () const</td></tr>
<tr class="separator:a62f877acb00d33a3725a41c767152a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e724b99fe1eb9b9a986a993da27b3b" id="r_a43e724b99fe1eb9b9a986a993da27b3b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a43e724b99fe1eb9b9a986a993da27b3b">max_alignment</a> () const</td></tr>
<tr class="separator:a43e724b99fe1eb9b9a986a993da27b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b60bbbb2b8ce922ab3b7a8b108dfb1c" id="r_a6b60bbbb2b8ce922ab3b7a8b108dfb1c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a6b60bbbb2b8ce922ab3b7a8b108dfb1c">try_allocate_node</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a6b60bbbb2b8ce922ab3b7a8b108dfb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf497be5547a51395e9275075f6fe5c" id="r_abbf497be5547a51395e9275075f6fe5c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#abbf497be5547a51395e9275075f6fe5c">try_allocate_array</a> (std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:abbf497be5547a51395e9275075f6fe5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896950eabdbbcb0a0724582f2982a38" id="r_a3896950eabdbbcb0a0724582f2982a38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a3896950eabdbbcb0a0724582f2982a38">try_deallocate_node</a> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a3896950eabdbbcb0a0724582f2982a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54163cfa5d6d68084cd9e7a8ee6f1dd4" id="r_a54163cfa5d6d68084cd9e7a8ee6f1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a54163cfa5d6d68084cd9e7a8ee6f1dd4">try_deallocate_array</a> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a54163cfa5d6d68084cd9e7a8ee6f1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0e22f6844a93ca183a896dc1e863a50" id="r_ad0e22f6844a93ca183a896dc1e863a50"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a> () noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classfoonathan_1_1memory_1_1reference__storage.html">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:ad0e22f6844a93ca183a896dc1e863a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a06e20d6de45e38d0ba1b5530e39be" id="r_a41a06e20d6de45e38d0ba1b5530e39be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a41a06e20d6de45e38d0ba1b5530e39be">get_allocator</a> () const noexcept -&gt; decltype(std::declval&lt; const <a class="el" href="classfoonathan_1_1memory_1_1reference__storage.html">storage_policy</a> &gt;().get_allocator())</td></tr>
<tr class="separator:a41a06e20d6de45e38d0ba1b5530e39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a66a278f215a3ffbeca3c3210f3590bd2" id="r_a66a278f215a3ffbeca3c3210f3590bd2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a66a278f215a3ffbeca3c3210f3590bd2">lock</a> () noexcept -&gt; implementation_defined</td></tr>
<tr class="separator:a66a278f215a3ffbeca3c3210f3590bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48460b3dba307eed96d35458fdb88367" id="r_a48460b3dba307eed96d35458fdb88367"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#a48460b3dba307eed96d35458fdb88367">lock</a> () const noexcept -&gt; implementation_defined</td></tr>
<tr class="separator:a48460b3dba307eed96d35458fdb88367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr class="memitem:a704415b59f769d1578478a9fbbbab698" id="r_a704415b59f769d1578478a9fbbbab698"><td class="memTemplParams" colspan="2">template&lt;class RawAllocator&gt; </td></tr>
<tr class="memitem:a704415b59f769d1578478a9fbbbab698"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a704415b59f769d1578478a9fbbbab698">make_allocator_reference</a> (RawAllocator &amp;&amp;allocator) noexcept -&gt; <a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt; typename std::decay&lt; RawAllocator &gt;::type &gt;</td></tr>
<tr class="separator:a704415b59f769d1578478a9fbbbab698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Functions</h2>
<a id="ab8b151450b913fc7140ace3938ffbb58" name="ab8b151450b913fc7140ace3938ffbb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b151450b913fc7140ace3938ffbb58">&#9670;&#160;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a757c28e5045efdd84d5c14de84e284ef" name="a757c28e5045efdd84d5c14de84e284ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757c28e5045efdd84d5c14de84e284ef">&#9670;&#160;</a></span>allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="af39c4c8201ed3a86738d5571239e19db" name="af39c4c8201ed3a86738d5571239e19db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c4c8201ed3a86738d5571239e19db">&#9670;&#160;</a></span>deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a7f89da0a2dbd6ad5089178c828bb95df" name="a7f89da0a2dbd6ad5089178c828bb95df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f89da0a2dbd6ad5089178c828bb95df">&#9670;&#160;</a></span>deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a64caa0912affaefd4778635a8a76294c" name="a64caa0912affaefd4778635a8a76294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64caa0912affaefd4778635a8a76294c">&#9670;&#160;</a></span>max_node_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_node_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a62f877acb00d33a3725a41c767152a5c" name="a62f877acb00d33a3725a41c767152a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f877acb00d33a3725a41c767152a5c">&#9670;&#160;</a></span>max_array_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_array_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a43e724b99fe1eb9b9a986a993da27b3b" name="a43e724b99fe1eb9b9a986a993da27b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e724b99fe1eb9b9a986a993da27b3b">&#9670;&#160;</a></span>max_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_alignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a6b60bbbb2b8ce922ab3b7a8b108dfb1c" name="a6b60bbbb2b8ce922ab3b7a8b108dfb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b60bbbb2b8ce922ab3b7a8b108dfb1c">&#9670;&#160;</a></span>try_allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * try_allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="abbf497be5547a51395e9275075f6fe5c" name="abbf497be5547a51395e9275075f6fe5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf497be5547a51395e9275075f6fe5c">&#9670;&#160;</a></span>try_allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * try_allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="a3896950eabdbbcb0a0724582f2982a38" name="a3896950eabdbbcb0a0724582f2982a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896950eabdbbcb0a0724582f2982a38">&#9670;&#160;</a></span>try_deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="a54163cfa5d6d68084cd9e7a8ee6f1dd4" name="a54163cfa5d6d68084cd9e7a8ee6f1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54163cfa5d6d68084cd9e7a8ee6f1dd4">&#9670;&#160;</a></span>try_deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="ad0e22f6844a93ca183a896dc1e863a50" name="ad0e22f6844a93ca183a896dc1e863a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e22f6844a93ca183a896dc1e863a50">&#9670;&#160;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;<a class="el" href="classfoonathan_1_1memory_1_1reference__storage.html">storage_policy</a>&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Forwards to the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="a41a06e20d6de45e38d0ba1b5530e39be" name="a41a06e20d6de45e38d0ba1b5530e39be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a06e20d6de45e38d0ba1b5530e39be">&#9670;&#160;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const <a class="el" href="classfoonathan_1_1memory_1_1reference__storage.html">storage_policy</a>&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Forwards to the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="a66a278f215a3ffbeca3c3210f3590bd2" name="a66a278f215a3ffbeca3c3210f3590bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a278f215a3ffbeca3c3210f3590bd2">&#9670;&#160;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; implementation_defined 
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="a48460b3dba307eed96d35458fdb88367" name="a48460b3dba307eed96d35458fdb88367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48460b3dba307eed96d35458fdb88367">&#9670;&#160;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; implementation_defined 
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="ac9c64316bb7697bc5b3cc48328369218" name="ac9c64316bb7697bc5b3cc48328369218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c64316bb7697bc5b3cc48328369218">&#9670;&#160;</a></span>is_composable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_composable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>Whether or not the stored allocator is composable, that is you can use the compositioning functions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to type-erased allocators, this function can not be <code>constexpr</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Related Functions</h2>
<a id="a704415b59f769d1578478a9fbbbab698" name="a704415b59f769d1578478a9fbbbab698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704415b59f769d1578478a9fbbbab698">&#9670;&#160;</a></span>make_allocator_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RawAllocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto make_allocator_reference </td>
          <td>(</td>
          <td class="paramtype">RawAllocator &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt;typename std::decay&lt;RawAllocator&gt;::type&gt;
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A new <a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a> object by forwarding the allocator to the constructor. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2
</small></address>
</body>
</html>
