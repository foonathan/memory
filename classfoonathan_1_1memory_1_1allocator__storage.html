<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: allocator_storage&lt; StoragePolicy, Mutex &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-methods">Member Functions</a>  </div>
  <div class="headertitle"><div class="title">allocator_storage&lt; StoragePolicy, Mutex &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__storage.html">Allocator storage</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class StoragePolicy, class Mutex&gt;<br />
class foonathan::memory::allocator_storage&lt; StoragePolicy, Mutex &gt;</div><p>A <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> that stores another allocator. </p>
<p>The <a href="md_doc_concepts.html#concept_storagepolicy">StoragePolicy</a> defines the allocator type being stored and how it is stored. The <code>Mutex</code> controls synchronization of the access. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd368539d4750dc2ea909343eed521b2" id="r_abd368539d4750dc2ea909343eed521b2"><td class="memItemLeft" align="right" valign="top"><a id="abd368539d4750dc2ea909343eed521b2" name="abd368539d4750dc2ea909343eed521b2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:abd368539d4750dc2ea909343eed521b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9615e22334e493ec6ef1f8588966cb2c" id="r_a9615e22334e493ec6ef1f8588966cb2c"><td class="memItemLeft" align="right" valign="top"><a id="a9615e22334e493ec6ef1f8588966cb2c" name="a9615e22334e493ec6ef1f8588966cb2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>storage_policy</b></td></tr>
<tr class="separator:a9615e22334e493ec6ef1f8588966cb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a0dfdee0c83539ff9725f255c81ef" id="r_a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memItemLeft" align="right" valign="top"><a id="a4a7a0dfdee0c83539ff9725f255c81ef" name="a4a7a0dfdee0c83539ff9725f255c81ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="separator:a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf829738ba45a0c47d96f529154baf0" id="r_aecf829738ba45a0c47d96f529154baf0"><td class="memItemLeft" align="right" valign="top"><a id="aecf829738ba45a0c47d96f529154baf0" name="aecf829738ba45a0c47d96f529154baf0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>is_stateful</b></td></tr>
<tr class="separator:aecf829738ba45a0c47d96f529154baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:a2980916240030f41c8dba8ada4914027" id="r_a2980916240030f41c8dba8ada4914027"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2980916240030f41c8dba8ada4914027">allocator_storage</a> ()=default</td></tr>
<tr class="separator:a2980916240030f41c8dba8ada4914027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce4f7585fa39e9b60e4ae81cf748b9b" id="r_a6ce4f7585fa39e9b60e4ae81cf748b9b"><td class="memTemplParams" colspan="2">template&lt;class Alloc&gt; </td></tr>
<tr class="memitem:a6ce4f7585fa39e9b60e4ae81cf748b9b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ce4f7585fa39e9b60e4ae81cf748b9b">allocator_storage</a> (Alloc &amp;&amp;alloc,)</td></tr>
<tr class="separator:a6ce4f7585fa39e9b60e4ae81cf748b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac362e66d464117a7e96e23b5155610af" id="r_ac362e66d464117a7e96e23b5155610af"><td class="memTemplParams" colspan="2">template&lt;class OtherPolicy&gt; </td></tr>
<tr class="memitem:ac362e66d464117a7e96e23b5155610af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac362e66d464117a7e96e23b5155610af">allocator_storage</a> (const <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; OtherPolicy, Mutex &gt; &amp;other,)</td></tr>
<tr class="separator:ac362e66d464117a7e96e23b5155610af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c64316bb7697bc5b3cc48328369218" id="r_ac9c64316bb7697bc5b3cc48328369218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9c64316bb7697bc5b3cc48328369218">is_composable</a> () const noexcept</td></tr>
<tr class="separator:ac9c64316bb7697bc5b3cc48328369218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a56d7233fc2658287acfe68b4407f7267" id="r_a56d7233fc2658287acfe68b4407f7267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56d7233fc2658287acfe68b4407f7267">allocator_storage</a> (<a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a56d7233fc2658287acfe68b4407f7267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664768a37aeb84a6794aea22c2a8b8f2" id="r_a664768a37aeb84a6794aea22c2a8b8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a664768a37aeb84a6794aea22c2a8b8f2">operator=</a> (<a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a664768a37aeb84a6794aea22c2a8b8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a244556cd8bd594aeddb55b784422b5e8" id="r_a244556cd8bd594aeddb55b784422b5e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a244556cd8bd594aeddb55b784422b5e8">allocator_storage</a> (const <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;)=default</td></tr>
<tr class="separator:a244556cd8bd594aeddb55b784422b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6253a9c68b376ac1c023c5e974bd345" id="r_af6253a9c68b376ac1c023c5e974bd345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6253a9c68b376ac1c023c5e974bd345">operator=</a> (const <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp;)=default</td></tr>
<tr class="separator:af6253a9c68b376ac1c023c5e974bd345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab8b151450b913fc7140ace3938ffbb58" id="r_ab8b151450b913fc7140ace3938ffbb58"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8b151450b913fc7140ace3938ffbb58">allocate_node</a> (std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:ab8b151450b913fc7140ace3938ffbb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757c28e5045efdd84d5c14de84e284ef" id="r_a757c28e5045efdd84d5c14de84e284ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a757c28e5045efdd84d5c14de84e284ef">allocate_array</a> (std::size_t count, std::size_t size, std::size_t alignment)</td></tr>
<tr class="separator:a757c28e5045efdd84d5c14de84e284ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c4c8201ed3a86738d5571239e19db" id="r_af39c4c8201ed3a86738d5571239e19db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af39c4c8201ed3a86738d5571239e19db">deallocate_node</a> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:af39c4c8201ed3a86738d5571239e19db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f89da0a2dbd6ad5089178c828bb95df" id="r_a7f89da0a2dbd6ad5089178c828bb95df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f89da0a2dbd6ad5089178c828bb95df">deallocate_array</a> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a7f89da0a2dbd6ad5089178c828bb95df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64caa0912affaefd4778635a8a76294c" id="r_a64caa0912affaefd4778635a8a76294c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64caa0912affaefd4778635a8a76294c">max_node_size</a> () const</td></tr>
<tr class="separator:a64caa0912affaefd4778635a8a76294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f877acb00d33a3725a41c767152a5c" id="r_a62f877acb00d33a3725a41c767152a5c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62f877acb00d33a3725a41c767152a5c">max_array_size</a> () const</td></tr>
<tr class="separator:a62f877acb00d33a3725a41c767152a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e724b99fe1eb9b9a986a993da27b3b" id="r_a43e724b99fe1eb9b9a986a993da27b3b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43e724b99fe1eb9b9a986a993da27b3b">max_alignment</a> () const</td></tr>
<tr class="separator:a43e724b99fe1eb9b9a986a993da27b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b60bbbb2b8ce922ab3b7a8b108dfb1c" id="r_a6b60bbbb2b8ce922ab3b7a8b108dfb1c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b60bbbb2b8ce922ab3b7a8b108dfb1c">try_allocate_node</a> (std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a6b60bbbb2b8ce922ab3b7a8b108dfb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf497be5547a51395e9275075f6fe5c" id="r_abbf497be5547a51395e9275075f6fe5c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbf497be5547a51395e9275075f6fe5c">try_allocate_array</a> (std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:abbf497be5547a51395e9275075f6fe5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896950eabdbbcb0a0724582f2982a38" id="r_a3896950eabdbbcb0a0724582f2982a38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3896950eabdbbcb0a0724582f2982a38">try_deallocate_node</a> (void *ptr, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a3896950eabdbbcb0a0724582f2982a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54163cfa5d6d68084cd9e7a8ee6f1dd4" id="r_a54163cfa5d6d68084cd9e7a8ee6f1dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54163cfa5d6d68084cd9e7a8ee6f1dd4">try_deallocate_array</a> (void *ptr, std::size_t count, std::size_t size, std::size_t alignment) noexcept</td></tr>
<tr class="separator:a54163cfa5d6d68084cd9e7a8ee6f1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0e22f6844a93ca183a896dc1e863a50" id="r_ad0e22f6844a93ca183a896dc1e863a50"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0e22f6844a93ca183a896dc1e863a50">get_allocator</a> () noexcept -&gt; decltype(std::declval&lt; storage_policy &gt;().get_allocator())</td></tr>
<tr class="separator:ad0e22f6844a93ca183a896dc1e863a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a06e20d6de45e38d0ba1b5530e39be" id="r_a41a06e20d6de45e38d0ba1b5530e39be"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41a06e20d6de45e38d0ba1b5530e39be">get_allocator</a> () const noexcept -&gt; decltype(std::declval&lt; const storage_policy &gt;().get_allocator())</td></tr>
<tr class="separator:a41a06e20d6de45e38d0ba1b5530e39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a66a278f215a3ffbeca3c3210f3590bd2" id="r_a66a278f215a3ffbeca3c3210f3590bd2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a278f215a3ffbeca3c3210f3590bd2">lock</a> () noexcept -&gt; implementation_defined</td></tr>
<tr class="separator:a66a278f215a3ffbeca3c3210f3590bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48460b3dba307eed96d35458fdb88367" id="r_a48460b3dba307eed96d35458fdb88367"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48460b3dba307eed96d35458fdb88367">lock</a> () const noexcept -&gt; implementation_defined</td></tr>
<tr class="separator:a48460b3dba307eed96d35458fdb88367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructors</h2>
<a id="a2980916240030f41c8dba8ada4914027" name="a2980916240030f41c8dba8ada4914027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2980916240030f41c8dba8ada4914027">&#9670;&#160;</a></span>allocator_storage() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates it by default-constructing the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The <code>StoragePolicy</code> must be default-constructible. </dd></dl>
<dl class="section user"><dt><em>Notes:</em></dt><dd>The default constructor may create an invalid allocator storage not associated with any allocator. If that is the case, it must not be used. </dd></dl>

</div>
</div>
<a id="a6ce4f7585fa39e9b60e4ae81cf748b9b" name="a6ce4f7585fa39e9b60e4ae81cf748b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce4f7585fa39e9b60e4ae81cf748b9b">&#9670;&#160;</a></span>allocator_storage() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> </td>
          <td>(</td>
          <td class="paramtype">Alloc &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates it by passing it an allocator. The allocator will be forwarded to the <code>StoragePolicy</code>, it decides whether it will be moved, its address stored or something else. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The expression <code>new storage_policy(std::forward&lt;Alloc&gt;(alloc))</code> must be well-formed, otherwise this constructor does not participate in overload resolution. </dd></dl>

</div>
</div>
<a id="ac362e66d464117a7e96e23b5155610af" name="ac362e66d464117a7e96e23b5155610af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac362e66d464117a7e96e23b5155610af">&#9670;&#160;</a></span>allocator_storage() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<div class="memtemplate">
template&lt;class OtherPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; OtherPolicy, Mutex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates it by passing it another <code>allocator_storage</code> with a different <code>StoragePolicy</code> but the same <code>Mutex</code> type. Initializes it with the result of <code>other.get_allocator()</code>. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The expression <code>new storage_policy(other.get_allocator())</code> must be well-formed, otherwise this constructor does not participate in overload resolution. </dd></dl>

</div>
</div>
<a id="a56d7233fc2658287acfe68b4407f7267" name="a56d7233fc2658287acfe68b4407f7267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d7233fc2658287acfe68b4407f7267">&#9670;&#160;</a></span>allocator_storage() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Moves the <code>allocator_storage</code> object. A moved-out <code>allocator_storage</code> object must still store a valid allocator object. </dd></dl>

</div>
</div>
<a id="a244556cd8bd594aeddb55b784422b5e8" name="a244556cd8bd594aeddb55b784422b5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244556cd8bd594aeddb55b784422b5e8">&#9670;&#160;</a></span>allocator_storage() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Copies the <code>allocator_storage</code> object. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The <code>StoragePolicy</code> must be copyable. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Functions</h2>
<a id="a664768a37aeb84a6794aea22c2a8b8f2" name="a664768a37aeb84a6794aea22c2a8b8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664768a37aeb84a6794aea22c2a8b8f2">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Moves the <code>allocator_storage</code> object. A moved-out <code>allocator_storage</code> object must still store a valid allocator object. </dd></dl>

</div>
</div>
<a id="af6253a9c68b376ac1c023c5e974bd345" name="af6253a9c68b376ac1c023c5e974bd345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6253a9c68b376ac1c023c5e974bd345">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html">allocator_storage</a>&lt; StoragePolicy, Mutex &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Copies the <code>allocator_storage</code> object. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The <code>StoragePolicy</code> must be copyable. </dd></dl>

</div>
</div>
<a id="ab8b151450b913fc7140ace3938ffbb58" name="ab8b151450b913fc7140ace3938ffbb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b151450b913fc7140ace3938ffbb58">&#9670;&#160;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a757c28e5045efdd84d5c14de84e284ef" name="a757c28e5045efdd84d5c14de84e284ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757c28e5045efdd84d5c14de84e284ef">&#9670;&#160;</a></span>allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void * allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="af39c4c8201ed3a86738d5571239e19db" name="af39c4c8201ed3a86738d5571239e19db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c4c8201ed3a86738d5571239e19db">&#9670;&#160;</a></span>deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a7f89da0a2dbd6ad5089178c828bb95df" name="a7f89da0a2dbd6ad5089178c828bb95df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f89da0a2dbd6ad5089178c828bb95df">&#9670;&#160;</a></span>deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a64caa0912affaefd4778635a8a76294c" name="a64caa0912affaefd4778635a8a76294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64caa0912affaefd4778635a8a76294c">&#9670;&#160;</a></span>max_node_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_node_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a62f877acb00d33a3725a41c767152a5c" name="a62f877acb00d33a3725a41c767152a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f877acb00d33a3725a41c767152a5c">&#9670;&#160;</a></span>max_array_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_array_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a43e724b99fe1eb9b9a986a993da27b3b" name="a43e724b99fe1eb9b9a986a993da27b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e724b99fe1eb9b9a986a993da27b3b">&#9670;&#160;</a></span>max_alignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_alignment </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>

</div>
</div>
<a id="a6b60bbbb2b8ce922ab3b7a8b108dfb1c" name="a6b60bbbb2b8ce922ab3b7a8b108dfb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b60bbbb2b8ce922ab3b7a8b108dfb1c">&#9670;&#160;</a></span>try_allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * try_allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="abbf497be5547a51395e9275075f6fe5c" name="abbf497be5547a51395e9275075f6fe5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf497be5547a51395e9275075f6fe5c">&#9670;&#160;</a></span>try_allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * try_allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="a3896950eabdbbcb0a0724582f2982a38" name="a3896950eabdbbcb0a0724582f2982a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896950eabdbbcb0a0724582f2982a38">&#9670;&#160;</a></span>try_deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="a54163cfa5d6d68084cd9e7a8ee6f1dd4" name="a54163cfa5d6d68084cd9e7a8ee6f1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54163cfa5d6d68084cd9e7a8ee6f1dd4">&#9670;&#160;</a></span>try_deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>alignment</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Calls the function on the stored composable allocator. The <code>Mutex</code> will be locked during the operation. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>The allocator must be composable, i.e. <a class="el" href="#ac9c64316bb7697bc5b3cc48328369218">is_composable()</a> must return <code>true</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This check is done at compile-time where possible, and at runtime in the case of type-erased storage. </dd></dl>

</div>
</div>
<a id="ad0e22f6844a93ca183a896dc1e863a50" name="ad0e22f6844a93ca183a896dc1e863a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e22f6844a93ca183a896dc1e863a50">&#9670;&#160;</a></span>get_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;storage_policy&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Forwards to the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="a41a06e20d6de45e38d0ba1b5530e39be" name="a41a06e20d6de45e38d0ba1b5530e39be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a06e20d6de45e38d0ba1b5530e39be">&#9670;&#160;</a></span>get_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const storage_policy&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Forwards to the <code>StoragePolicy</code>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>Returns a reference to the stored allocator. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This does not lock the <code>Mutex</code>. </dd></dl>

</div>
</div>
<a id="a66a278f215a3ffbeca3c3210f3590bd2" name="a66a278f215a3ffbeca3c3210f3590bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a278f215a3ffbeca3c3210f3590bd2">&#9670;&#160;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt; implementation_defined 
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="a48460b3dba307eed96d35458fdb88367" name="a48460b3dba307eed96d35458fdb88367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48460b3dba307eed96d35458fdb88367">&#9670;&#160;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const -&gt; implementation_defined 
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A proxy object that acts like a pointer to the stored allocator. It cannot be reassigned to point to another allocator object and only moving is supported, which is destructive. As long as the proxy object lives and is not moved from, the <code>Mutex</code> will be kept locked. </dd></dl>

</div>
</div>
<a id="ac9c64316bb7697bc5b3cc48328369218" name="ac9c64316bb7697bc5b3cc48328369218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c64316bb7697bc5b3cc48328369218">&#9670;&#160;</a></span>is_composable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StoragePolicy, class Mutex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_composable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>Whether or not the stored allocator is composable, that is you can use the compositioning functions. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Due to type-erased allocators, this function can not be <code>constexpr</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2
</small></address>
</body>
</html>
