<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div><div class="header">
  <div class="headertitle"><div class="title">memory </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_2index"></a> This is the documentation of <code>foonathan/memory</code>.</p>
<p>For a quick start, read the <a href="md_doc_tutorial.html">Tutorial</a> or skim the examples at the <a href="https://github.com/foonathan/memory/">Github page</a>. The concepts of this library are defined are <a href="md_doc_concepts.html">here</a>.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Features</h2>
<p>New allocator concepts:</p>
<ul>
<li>a <code>RawAllocator</code> that is similar to an <code>Allocator</code> but easier to use and write</li>
<li>a <code>BlockAllocator</code> that is an allocator for huge memory blocks</li>
</ul>
<p>Several implementations:</p>
<ul>
<li><code>heap_/malloc_/new_allocator</code></li>
<li>virtual memory allocators</li>
<li>allocator using a static memory block located on the stack</li>
<li>memory stack</li>
<li>different memory pools</li>
<li>a portable, improved <code>alloca()</code> in the form of <code>temporary_allocator</code></li>
</ul>
<p>Adapters, wrappers and storage classes:</p>
<ul>
<li>incredible powerful <code>allocator_traits</code> allowing <code>Allocator</code>s as <code>RawAllocator</code>s</li>
<li><code>std_allocator</code> to make a <code>RawAllocator</code> an <code>Allocator</code> again</li>
<li>adapters for the memory resource TS</li>
<li><code>allocator_deleter</code> classes for smart pointers</li>
<li>(optionally type-erased) <code>allocator_reference</code> and other storage classes</li>
<li>memory tracking wrapper</li>
</ul>
<p>In addition:</p>
<ul>
<li>container node size debuggers that obtain information about the node size of an STL container at compile-time to specify node sizes for pools</li>
<li>debugging options for leak checking, double-free checks or buffer overflows</li>
<li>customizable error handling routines that can work with exceptions disabled</li>
<li>everything except the STL adapters works on a freestanding environment</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Basic example</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="container_8hpp.html">foonathan/memory/container.hpp</a>&gt;</span>        <span class="comment">// vector, list, list_node_size,...</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="memory__pool_8hpp.html">foonathan/memory/memory_pool.hpp</a>&gt;</span>      <span class="comment">// memory_pool</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="smart__ptr_8hpp.html">foonathan/memory/smart_ptr.hpp</a>&gt;</span>        <span class="comment">// allocate_unique</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="static__allocator_8hpp.html">foonathan/memory/static_allocator.hpp</a>&gt;</span> <span class="comment">// static_allocator_storage, static_block_allocator</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="temporary__allocator_8hpp.html">foonathan/memory/temporary_allocator.hpp</a>&gt;</span> <span class="comment">// temporary_allocator</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// alias namespace foonathan::memory as memory for easier access</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="namespace__alias_8hpp.html">foonathan/memory/namespace_alias.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BiIter&gt;</div>
<div class="line"><span class="keywordtype">void</span> merge_sort(BiIter begin, BiIter end);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacefoonathan_1_1memory_1_1literals.html">memory::literals</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a memory pool RawAllocator</span></div>
<div class="line">    <span class="comment">// allocates a memory block - initially 4KiB - and splits it into chunks of list_node_size&lt;int&gt;::value big</span></div>
<div class="line">    <span class="comment">// list_node_size&lt;int&gt;::value is the size of each node of a std::list</span></div>
<div class="line">    <a class="code hl_class" href="classfoonathan_1_1memory_1_1memory__pool.html">memory::memory_pool&lt;&gt;</a> pool(<a class="code hl_struct" href="structfoonathan_1_1memory_1_1list__node__size.html">memory::list_node_size&lt;int&gt;::value</a>, 4_KiB);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// just an alias for std::list&lt;int, memory::std_allocator&lt;int, memory::memory_pool&lt;&gt;&gt;</span></div>
<div class="line">    <span class="comment">// a std::list using a memory_pool</span></div>
<div class="line">    <span class="comment">// std_allocator stores a reference to a RawAllocator and provides the Allocator interface</span></div>
<div class="line">    <a class="code hl_class" href="classfoonathan_1_1memory_1_1list.html">memory::list&lt;int, memory::memory_pool&lt;&gt;</a>&gt; list(pool);</div>
<div class="line">    list.push_back(3);</div>
<div class="line">    list.push_back(2);</div>
<div class="line">    list.push_back(1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : list)</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    merge_sort(list.begin(), list.end());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : list)</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// allocate a std::unique_ptr using the pool</span></div>
<div class="line">    <span class="comment">// memory::allocate_shared is also available</span></div>
<div class="line">    <span class="keyword">auto</span> ptr = <a class="code hl_function" href="group__adapter.html#ga1de954b249351450f5f8ea6c5e69bd9c">memory::allocate_unique&lt;int&gt;</a>(pool, *list.begin());</div>
<div class="line">    std::cout &lt;&lt; *ptr &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// static storage of size 4KiB</span></div>
<div class="line">    <a class="code hl_struct" href="structfoonathan_1_1memory_1_1static__allocator__storage.html">memory::static_allocator_storage&lt;4_KiB&gt;</a> storage;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// a memory pool again but this time with a BlockAllocator</span></div>
<div class="line">    <span class="comment">// this controls the internal allocations of the pool itself</span></div>
<div class="line">    <span class="comment">// we need to specify the first template parameter giving the type of the pool as well</span></div>
<div class="line">    <span class="comment">// (node_pool is the default)</span></div>
<div class="line">    <span class="comment">// we use a static_block_allocator that uses the static storage above</span></div>
<div class="line">    <span class="comment">// all allocations will use a memory block on the stack</span></div>
<div class="line">    <span class="keyword">using </span>static_pool_t = <a class="code hl_class" href="classfoonathan_1_1memory_1_1memory__pool.html">memory::memory_pool&lt;memory::node_pool, memory::static_block_allocator&gt;</a>;</div>
<div class="line">    static_pool_t static_pool(<a class="code hl_struct" href="structfoonathan_1_1memory_1_1unordered__set__node__size.html">memory::unordered_set_node_size&lt;int&gt;::value</a>, 4_KiB, storage);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// again, just an alias for std::unordered_set&lt;int, std::hash&lt;int&gt;, std::equal_to&lt;int&gt;, memory::std_allocator&lt;int, static_pool_t&gt;</span></div>
<div class="line">    <span class="comment">// see why I wrote these? :D</span></div>
<div class="line">    <span class="comment">// now we have a hash set that lives on the stack!</span></div>
<div class="line">    <a class="code hl_class" href="classfoonathan_1_1memory_1_1unordered__set.html">memory::unordered_set&lt;int, static_pool_t&gt;</a></div>
<div class="line">        set(13, std::hash&lt;int&gt;{}, std::equal_to&lt;int&gt;{},</div>
<div class="line">            static_pool); <span class="comment">// GCC 4.7 is missing the allocator-only ctor, breaks travis :(</span></div>
<div class="line"> </div>
<div class="line">    set.insert(3);</div>
<div class="line">    set.insert(2);</div>
<div class="line">    set.insert(3); <span class="comment">// running out of stack memory is properly handled, of course</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : set)</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// naive implementation of merge_sort using temporary memory allocator</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BiIter&gt;</div>
<div class="line"><span class="keywordtype">void</span> merge_sort(BiIter begin, BiIter end)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>value_type = <span class="keyword">typename</span> std::iterator_traits&lt;BiIter&gt;::value_type;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> distance = std::distance(begin, end);</div>
<div class="line">    <span class="keywordflow">if</span> (distance &lt;= 1)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> mid = begin;</div>
<div class="line">    std::advance(mid, distance / 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// an allocator for temporary memory</span></div>
<div class="line">    <span class="comment">// is similar to alloca() but uses its own stack</span></div>
<div class="line">    <span class="comment">// this stack is thread_local and created the first time it&#39;s needed</span></div>
<div class="line">    <span class="comment">// as soon as the allocator object goes out of scope everything allocated through it will be freed</span></div>
<div class="line">    <a class="code hl_class" href="classfoonathan_1_1memory_1_1temporary__allocator.html">memory::temporary_allocator</a> alloc;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// alias for std::vector&lt;value_type, memory::std_allocator&lt;value_type, memory::temporary_allocator&gt;&gt;</span></div>
<div class="line">    <span class="comment">// a std::vector using a temporary_allocator</span></div>
<div class="line">    <a class="code hl_class" href="classfoonathan_1_1memory_1_1vector.html">memory::vector&lt;value_type, memory::temporary_allocator&gt;</a> first(begin, mid, alloc),</div>
<div class="line">        second(mid, end, alloc);</div>
<div class="line"> </div>
<div class="line">    merge_sort(first.begin(), first.end());</div>
<div class="line">    merge_sort(second.begin(), second.end());</div>
<div class="line">    std::merge(first.begin(), first.end(), second.begin(), second.end(), begin);</div>
<div class="line">}</div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1list_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1list.html">foonathan::memory::list</a></div><div class="ttdoc">Alias template for an STL container that uses a certain RawAllocator.</div><div class="ttdef"><b>Definition</b> container.hpp:66</div></div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1memory__pool_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1memory__pool.html">foonathan::memory::memory_pool</a></div><div class="ttdoc">A stateful RawAllocator that manages nodes of fixed size.</div><div class="ttdef"><b>Definition</b> memory_pool.hpp:49</div></div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1temporary__allocator_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1temporary__allocator.html">foonathan::memory::temporary_allocator</a></div><div class="ttdoc">A stateful RawAllocator that handles temporary allocations.</div><div class="ttdef"><b>Definition</b> temporary_allocator.hpp:220</div></div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1unordered__set_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1unordered__set.html">foonathan::memory::unordered_set</a></div><div class="ttdoc">Alias template for an STL container that uses a certain RawAllocator.</div><div class="ttdef"><b>Definition</b> container.hpp:134</div></div>
<div class="ttc" id="aclassfoonathan_1_1memory_1_1vector_html"><div class="ttname"><a href="classfoonathan_1_1memory_1_1vector.html">foonathan::memory::vector</a></div><div class="ttdoc">Alias template for an STL container that uses a certain RawAllocator.</div><div class="ttdef"><b>Definition</b> container.hpp:46</div></div>
<div class="ttc" id="acontainer_8hpp_html"><div class="ttname"><a href="container_8hpp.html">container.hpp</a></div><div class="ttdoc">Aliasas for STL containers using a certain RawAllocator.</div></div>
<div class="ttc" id="agroup__adapter_html_ga1de954b249351450f5f8ea6c5e69bd9c"><div class="ttname"><a href="group__adapter.html#ga1de954b249351450f5f8ea6c5e69bd9c">foonathan::memory::allocate_unique</a></div><div class="ttdeci">auto allocate_unique(RawAllocator &amp;&amp;alloc, Args &amp;&amp;... args) -&gt;</div><div class="ttdoc">Creates a std::unique_ptr using a RawAllocator for the allocation.</div><div class="ttdef"><b>Definition</b> smart_ptr.hpp:116</div></div>
<div class="ttc" id="amemory__pool_8hpp_html"><div class="ttname"><a href="memory__pool_8hpp.html">memory_pool.hpp</a></div><div class="ttdoc">Class memory_pool and its allocator_traits specialization.</div></div>
<div class="ttc" id="anamespace__alias_8hpp_html"><div class="ttname"><a href="namespace__alias_8hpp.html">namespace_alias.hpp</a></div><div class="ttdoc">Convenient namespace alias.</div></div>
<div class="ttc" id="anamespacefoonathan_1_1memory_1_1literals_html"><div class="ttname"><a href="namespacefoonathan_1_1memory_1_1literals.html">foonathan::memory::literals</a></div><div class="ttdoc">Literals namespace.</div><div class="ttdef"><b>Definition</b> memory_arena.hpp:654</div></div>
<div class="ttc" id="asmart__ptr_8hpp_html"><div class="ttname"><a href="smart__ptr_8hpp.html">smart_ptr.hpp</a></div><div class="ttdoc">std::make_unique() / std::make_shared() replacement allocating memory through a RawAllocator.</div></div>
<div class="ttc" id="astatic__allocator_8hpp_html"><div class="ttname"><a href="static__allocator_8hpp.html">static_allocator.hpp</a></div><div class="ttdoc">Allocators using a static, fixed-sized storage.</div></div>
<div class="ttc" id="astructfoonathan_1_1memory_1_1list__node__size_html"><div class="ttname"><a href="structfoonathan_1_1memory_1_1list__node__size.html">foonathan::memory::list_node_size</a></div><div class="ttdoc">Contains the node size of a node based STL container with a specific type.</div><div class="ttdef"><b>Definition</b> container.hpp:289</div></div>
<div class="ttc" id="astructfoonathan_1_1memory_1_1static__allocator__storage_html"><div class="ttname"><a href="structfoonathan_1_1memory_1_1static__allocator__storage.html">foonathan::memory::static_allocator_storage</a></div><div class="ttdoc">Storage for a static_allocator.</div><div class="ttdef"><b>Definition</b> static_allocator.hpp:33</div></div>
<div class="ttc" id="astructfoonathan_1_1memory_1_1unordered__set__node__size_html"><div class="ttname"><a href="structfoonathan_1_1memory_1_1unordered__set__node__size.html">foonathan::memory::unordered_set_node_size</a></div><div class="ttdoc">Contains the node size of a node based STL container with a specific type.</div><div class="ttdef"><b>Definition</b> container.hpp:307</div></div>
<div class="ttc" id="atemporary__allocator_8hpp_html"><div class="ttname"><a href="temporary__allocator_8hpp.html">temporary_allocator.hpp</a></div><div class="ttdoc">Class temporary_allocator and related functions.</div></div>
</div><!-- fragment --><p>See <code>example/</code> for more.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Installation</h2>
<p>This library can be used as [CMake] subdirectory. It is tested on GCC 4.7-4.9, Clang 3.4-3.5 and Visual Studio 2013. Newer versions should work too.</p>
<ol type="1">
<li>Fetch it, e.g. using [git submodules] <code>git submodule add <a href="https://github.com/foonathan/memory">https://github.com/foonathan/memory</a> ext/memory</code> and <code>git submodule update --init --recursive</code>.</li>
<li>Call <code>add_subdirectory(ext/memory)</code> or whatever your local path is to make it available in CMake.</li>
<li>Simply call <code>target_link_libraries(your_target PUBLIC foonathan_memory)</code> to link this library and setups the include search path.</li>
<li>You need to activate C++11 at your target, if not already done, you can use [foonathan/compatibility] already available through <code>add_subdirectory()</code> and call <code>comp_target_features(your_target PUBLIC CPP11)</code>.</li>
</ol>
<p><em>Note: If during CMake you see an error message that compatibility is not on the newest version, run <code>git submodule update --recursive --remote</code> to force the compatiblity submodule of memory to update to the latest version.</em></p>
<p>You can also install the library:</p>
<ol type="1">
<li>Run <code>cmake -DCMAKE_BUILD_TYPE="buildtype" -DFOONATHAN_MEMORY_BUILD_EXAMPLES=OFF -DFOONATHAN_MEMORY_BUILD_TESTS=OFF .</code> inside the library sources.</li>
<li>Run <code>cmake --build . -- install</code> to install the library under <code>${CMAKE_INSTALL_PREFIX}</code>.</li>
<li>Repeat 1 and 2 for each build type/configuration you want to have (like <code>Debug</code>, <code>RelWithDebInfo</code> and <code>Release</code> or custom names).</li>
</ol>
<p>The use an installed library:</p>
<ol type="1">
<li>Call <code>find_package(foonathan_memory major.minor REQUIRED)</code> to find the library.</li>
<li>Call <code>target_link_libraries(your_target PUBLIC foonathan_memory)</code> and activate C++11 to link to the library.</li>
</ol>
<p>See <a href="https://memory.foonathan.net/md_doc_installation.html">https://memory.foonathan.net/md_doc_installation.html</a> for a detailed guide.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
About this documentation</h2>
<p>This documentation is written in a similar way as the C++ standard itself, although not that formal.</p>
<p>Concepts are documented using the names of the template parameters, for example the following class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Tracker, <span class="keyword">class</span> RawAllocator&gt;</div>
<div class="line"><span class="keyword">class </span>tracked_allocator;</div>
</div><!-- fragment --><p>It takes two template parameters, the first must model the <a href="md_doc_concepts.html#concept_tracker">Tracker</a> concept, the second the <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> concept.</p>
<p>Unless explicitly stated otherwise, it is not allowed to call a function that modifies state from two different threads. Functions that modify state are non-<code>const</code> member functions, functions taking a non-<code>const</code> reference to objects or functions where it is explictly documented that they change some hidden state.</p>
<p>If a function is documented as <code>noexcept</code>, it does not throw anything. Otherwise it has a <em>Throws:</em> clause specifying what it throws, or if it is a forwarding function, the information can be found there (see below).</p>
<p>If a class is described as <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> it automatically has certain semantically information which are not explictly mentioned. This is especially true for the member functions of an <a class="el" href="classfoonathan_1_1memory_1_1allocator__traits.html">allocator_traits</a> specialization.</p>
<p>If a function is described as returning the value of another function or forwarding to it, it implicitly has the requirements and effects from the called function and can also throw the same things. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2
</small></address>
</body>
</html>
