<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: Core components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="group__memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Core components</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class that checks whether or not a standard <code>Allocator</code> can be used as <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html">allocator_is_raw_allocator&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a> that allows <code>std::allocator</code> again.  <a href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__traits.html">allocator_traits&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the allocator_traits for a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="classfoonathan_1_1memory_1_1allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__raw__allocator.html">is_raw_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="structfoonathan_1_1memory_1_1is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the composable_allocator_traits for a <a href="md_doc_concepts.html#concept_composableallocator">ComposableAllocator</a>.  <a href="classfoonathan_1_1memory_1_1composable__allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__composable__allocator.html">is_composable_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept <a href="md_doc_concepts.html#concept_rawallocator">ComposableAllocator</a>.  <a href="structfoonathan_1_1memory_1_1is__composable__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about an allocator.  <a href="structfoonathan_1_1memory_1_1allocator__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1out__of__memory.html">out_of_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when a low level allocator runs out of memory.  <a href="classfoonathan_1_1memory_1_1out__of__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1out__of__fixed__memory.html">out_of_fixed_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classfoonathan_1_1memory_1_1out__of__memory.html">out_of_memory</a> errors thrown when a low-level allocator with a fixed size runs out of memory.  <a href="classfoonathan_1_1memory_1_1out__of__fixed__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when an allocation size is bigger than the supported maximum.  <a href="classfoonathan_1_1memory_1_1bad__allocation__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__node__size.html">bad_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the node size exceeds the supported maximum, i.e.  <a href="classfoonathan_1_1memory_1_1bad__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__array__size.html">bad_array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the array size exceeds the supported maximum, i.e.  <a href="classfoonathan_1_1memory_1_1bad__array__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__alignment.html">bad_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the alignment exceeds the supported maximum, i.e.  <a href="classfoonathan_1_1memory_1_1bad__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory block.  <a href="structfoonathan_1_1memory_1_1memory__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__block__allocator.html">is_block_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>.  <a href="structfoonathan_1_1memory_1_1is__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena&lt; BlockAllocator, Cached &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena that manages huge memory blocks for a higher-level allocator.  <a href="classfoonathan_1_1memory_1_1memory__arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">no_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy <code>Mutex</code> class that does not lock anything.  <a href="structfoonathan_1_1memory_1_1no__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__thread__safe__allocator.html">is_thread_safe_allocator&lt; RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> is thread safe as-is.  <a href="structfoonathan_1_1memory_1_1is__thread__safe__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga57ff31908827db59ce4900bd636ed1d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga57ff31908827db59ce4900bd636ed1d8">FOONATHAN_MEMORY_VERSION_MAJOR</a></td></tr>
<tr class="memdesc:ga57ff31908827db59ce4900bd636ed1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The major version number.  <a href="group__core.html#ga57ff31908827db59ce4900bd636ed1d8">More...</a><br /></td></tr>
<tr class="separator:ga57ff31908827db59ce4900bd636ed1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c78c0886db56a1bd18dd9c023c7bb3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga1c78c0886db56a1bd18dd9c023c7bb3f">FOONATHAN_MEMORY_VERSION_MINOR</a></td></tr>
<tr class="memdesc:ga1c78c0886db56a1bd18dd9c023c7bb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minor version number.  <a href="group__core.html#ga1c78c0886db56a1bd18dd9c023c7bb3f">More...</a><br /></td></tr>
<tr class="separator:ga1c78c0886db56a1bd18dd9c023c7bb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga323b74fa31dd5419b2eb9af6f04e49ef">FOONATHAN_MEMORY_VERSION</a></td></tr>
<tr class="memdesc:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total version number of the form <code>Mmm</code>.  <a href="group__core.html#ga323b74fa31dd5419b2eb9af6f04e49ef">More...</a><br /></td></tr>
<tr class="separator:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga323b74fa31dd5419b2eb9af6f04e49ef">FOONATHAN_MEMORY_VERSION</a></td></tr>
<tr class="memdesc:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total version number of the form <code>Mmm</code>.  <a href="group__core.html#ga323b74fa31dd5419b2eb9af6f04e49ef">More...</a><br /></td></tr>
<tr class="separator:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c74366ce94e4b30e7f8075fd46d3c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gab9c74366ce94e4b30e7f8075fd46d3c9">FOONATHAN_MEMORY_CHECK_ALLOCATION_SIZE</a></td></tr>
<tr class="memdesc:gab9c74366ce94e4b30e7f8075fd46d3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the allocation size will be checked, i.e.  <a href="group__core.html#gab9c74366ce94e4b30e7f8075fd46d3c9">More...</a><br /></td></tr>
<tr class="separator:gab9c74366ce94e4b30e7f8075fd46d3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8321c1ee9ddb2e5610249e39c79cf5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac8321c1ee9ddb2e5610249e39c79cf5f">FOONATHAN_MEMORY_THREAD_SAFE_REFERENCE</a></td></tr>
<tr class="memdesc:gac8321c1ee9ddb2e5610249e39c79cf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the <a class="el" href="group__core.html#gaee2f0e3847e0ab64384e5e8c8f1a7a27">foonathan::memory::default_mutex</a> will be <code>std::mutex</code> or <a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">foonathan::memory::no_mutex</a>.  <a href="group__core.html#gac8321c1ee9ddb2e5610249e39c79cf5f">More...</a><br /></td></tr>
<tr class="separator:gac8321c1ee9ddb2e5610249e39c79cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeca7ca88417f547b94c8013ee774665"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gadeca7ca88417f547b94c8013ee774665">FOONATHAN_MEMORY_DEBUG_ASSERT</a></td></tr>
<tr class="memdesc:gadeca7ca88417f547b94c8013ee774665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not internal assertions in the library are enabled.  <a href="group__core.html#gadeca7ca88417f547b94c8013ee774665">More...</a><br /></td></tr>
<tr class="separator:gadeca7ca88417f547b94c8013ee774665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec921be38dec717ec1b6158672d445a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a></td></tr>
<tr class="memdesc:gaec921be38dec717ec1b6158672d445a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not allocated memory will be filled with special values.  <a href="group__core.html#gaec921be38dec717ec1b6158672d445a5">More...</a><br /></td></tr>
<tr class="separator:gaec921be38dec717ec1b6158672d445a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef525b4cee8ed9b5fb9c306fbcff9cda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaef525b4cee8ed9b5fb9c306fbcff9cda">FOONATHAN_MEMORY_DEBUG_FENCE</a></td></tr>
<tr class="memdesc:gaef525b4cee8ed9b5fb9c306fbcff9cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the fence memory, it has no effect if <a class="el" href="group__core.html#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>false</code>.  <a href="group__core.html#gaef525b4cee8ed9b5fb9c306fbcff9cda">More...</a><br /></td></tr>
<tr class="separator:gaef525b4cee8ed9b5fb9c306fbcff9cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c19666f4d048ef6b5c2fd190228414"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga56c19666f4d048ef6b5c2fd190228414">FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</a></td></tr>
<tr class="memdesc:ga56c19666f4d048ef6b5c2fd190228414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not leak checking is enabled.  <a href="group__core.html#ga56c19666f4d048ef6b5c2fd190228414">More...</a><br /></td></tr>
<tr class="separator:ga56c19666f4d048ef6b5c2fd190228414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c494b053a54906e07e66779838a1b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga77c494b053a54906e07e66779838a1b0">FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</a></td></tr>
<tr class="memdesc:ga77c494b053a54906e07e66779838a1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the deallocation functions will check for pointers that were never allocated by an allocator.  <a href="group__core.html#ga77c494b053a54906e07e66779838a1b0">More...</a><br /></td></tr>
<tr class="separator:ga77c494b053a54906e07e66779838a1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e74e0d00f7dabde7e8cce1b67c8d90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga58e74e0d00f7dabde7e8cce1b67c8d90">FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a></td></tr>
<tr class="memdesc:ga58e74e0d00f7dabde7e8cce1b67c8d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the deallocation functions will check for double free errors.  <a href="group__core.html#ga58e74e0d00f7dabde7e8cce1b67c8d90">More...</a><br /></td></tr>
<tr class="separator:ga58e74e0d00f7dabde7e8cce1b67c8d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fad87dece498b3fc56679b0906c336"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga12fad87dece498b3fc56679b0906c336">FOONATHAN_MEMORY_NAMESPACE_PREFIX</a></td></tr>
<tr class="memdesc:ga12fad87dece498b3fc56679b0906c336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not everything is in namespace <code>foonathan::memory</code>.  <a href="group__core.html#ga12fad87dece498b3fc56679b0906c336">More...</a><br /></td></tr>
<tr class="separator:ga12fad87dece498b3fc56679b0906c336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac9a31890ea6cb62d78938b43c9a496fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> = void(*)(const <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a> &amp;info, std::ptrdiff_t amount)</td></tr>
<tr class="memdesc:gac9a31890ea6cb62d78938b43c9a496fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a memory leak is detected.  <a href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">More...</a><br /></td></tr>
<tr class="separator:gac9a31890ea6cb62d78938b43c9a496fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7055c92f3a0acf2f41d2090b7c1a5074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> = void(*)(const <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a> &amp;info, const void *ptr)</td></tr>
<tr class="memdesc:ga7055c92f3a0acf2f41d2090b7c1a5074"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when an invalid pointer is passed to a deallocation function.  <a href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">More...</a><br /></td></tr>
<tr class="separator:ga7055c92f3a0acf2f41d2090b7c1a5074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga055130bf52afd8d252a58ba57eb19799"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a> = void(*)(const void *memory, std::size_t size, const void *write_ptr)</td></tr>
<tr class="memdesc:ga055130bf52afd8d252a58ba57eb19799"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a buffer under/overflow is detected.  <a href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">More...</a><br /></td></tr>
<tr class="separator:ga055130bf52afd8d252a58ba57eb19799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7651169a0cdd3612f5d8fc7baba505b"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </td></tr>
<tr class="memitem:gaf7651169a0cdd3612f5d8fc7baba505b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a> = implementation_defined</td></tr>
<tr class="memdesc:gaf7651169a0cdd3612f5d8fc7baba505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes either a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> or a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">More...</a><br /></td></tr>
<tr class="separator:gaf7651169a0cdd3612f5d8fc7baba505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2f0e3847e0ab64384e5e8c8f1a7a27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaee2f0e3847e0ab64384e5e8c8f1a7a27">default_mutex</a> = <a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">no_mutex</a></td></tr>
<tr class="memdesc:gaee2f0e3847e0ab64384e5e8c8f1a7a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default <code>Mutex</code> type used as default template paremeter in, e.g.  <a href="group__core.html#gaee2f0e3847e0ab64384e5e8c8f1a7a27">More...</a><br /></td></tr>
<tr class="separator:gaee2f0e3847e0ab64384e5e8c8f1a7a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab1db4d7ca0241d511710324c01f27b23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gab1db4d7ca0241d511710324c01f27b23">debug_magic</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23a7bd4be20559c1a287369c8df4c117afe">internal_memory</a>, 
<a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23aa5c32a0fcc06d646d53c71b55c9cf5cb">internal_freed_memory</a>, 
<a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23a9e1988b82181dbe51272459a8ac8e0c0">new_memory</a>, 
<a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23a635e5f9da5635b909461fd93c09130ed">freed_memory</a>, 
<br />
&#160;&#160;<a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23a682318fff515ed43a48b718f46c21308">alignment_memory</a>, 
<a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360">fence_memory</a>
<br />
 }</td></tr>
<tr class="memdesc:gab1db4d7ca0241d511710324c01f27b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The magic values that are used for debug filling.  <a href="group__core.html#gab1db4d7ca0241d511710324c01f27b23">More...</a><br /></td></tr>
<tr class="separator:gab1db4d7ca0241d511710324c01f27b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5415329fb8f760eed33cb0f9a8eaed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac5415329fb8f760eed33cb0f9a8eaed5">set_leak_handler</a> (<a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> h)</td></tr>
<tr class="memdesc:gac5415329fb8f760eed33cb0f9a8eaed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>.  <a href="group__core.html#gac5415329fb8f760eed33cb0f9a8eaed5">More...</a><br /></td></tr>
<tr class="separator:gac5415329fb8f760eed33cb0f9a8eaed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32882ffa8bd8feafe3334e7b9b6ca8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga32882ffa8bd8feafe3334e7b9b6ca8c6">get_leak_handler</a> ()</td></tr>
<tr class="memdesc:ga32882ffa8bd8feafe3334e7b9b6ca8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>.  <a href="group__core.html#ga32882ffa8bd8feafe3334e7b9b6ca8c6">More...</a><br /></td></tr>
<tr class="separator:ga32882ffa8bd8feafe3334e7b9b6ca8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad22a929516dd5a2e9e326f2c5c8326df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gad22a929516dd5a2e9e326f2c5c8326df">set_invalid_pointer_handler</a> (<a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> h)</td></tr>
<tr class="memdesc:gad22a929516dd5a2e9e326f2c5c8326df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>.  <a href="group__core.html#gad22a929516dd5a2e9e326f2c5c8326df">More...</a><br /></td></tr>
<tr class="separator:gad22a929516dd5a2e9e326f2c5c8326df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3fa468c245a855bb39074df3d74ff95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gac3fa468c245a855bb39074df3d74ff95">get_invalid_pointer_handler</a> ()</td></tr>
<tr class="memdesc:gac3fa468c245a855bb39074df3d74ff95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>.  <a href="group__core.html#gac3fa468c245a855bb39074df3d74ff95">More...</a><br /></td></tr>
<tr class="separator:gac3fa468c245a855bb39074df3d74ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad786a5a56d768a5be1e13a769ea19f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gad786a5a56d768a5be1e13a769ea19f74">set_buffer_overflow_handler</a> (<a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a> h)</td></tr>
<tr class="memdesc:gad786a5a56d768a5be1e13a769ea19f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>.  <a href="group__core.html#gad786a5a56d768a5be1e13a769ea19f74">More...</a><br /></td></tr>
<tr class="separator:gad786a5a56d768a5be1e13a769ea19f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6771bda16c1cd6da0c456c28415774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga7f6771bda16c1cd6da0c456c28415774">get_buffer_overflow_handler</a> ()</td></tr>
<tr class="memdesc:ga7f6771bda16c1cd6da0c456c28415774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>.  <a href="group__core.html#ga7f6771bda16c1cd6da0c456c28415774">More...</a><br /></td></tr>
<tr class="separator:ga7f6771bda16c1cd6da0c456c28415774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc824b77744b3bc5074b71c252b8f81"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga5cc824b77744b3bc5074b71c252b8f81">cached_arena</a></td></tr>
<tr class="separator:ga5cc824b77744b3bc5074b71c252b8f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5ff9c47c6c768c7d5b9937f4df2434"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga1b5ff9c47c6c768c7d5b9937f4df2434">uncached_arena</a></td></tr>
<tr class="separator:ga1b5ff9c47c6c768c7d5b9937f4df2434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e85082887bdf9000fbaf5f6138a61"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga5c1e85082887bdf9000fbaf5f6138a61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga5c1e85082887bdf9000fbaf5f6138a61">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga5c1e85082887bdf9000fbaf5f6138a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70667a30ead35eaee18f32c3b3e1db6c"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator , typename... Args&gt; </td></tr>
<tr class="memitem:ga70667a30ead35eaee18f32c3b3e1db6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core.html#ga70667a30ead35eaee18f32c3b3e1db6c">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga70667a30ead35eaee18f32c3b3e1db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Defines</h2>
<a id="ga57ff31908827db59ce4900bd636ed1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ff31908827db59ce4900bd636ed1d8">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_VERSION_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION_MAJOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The major version number. </p>

</div>
</div>
<a id="ga1c78c0886db56a1bd18dd9c023c7bb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c78c0886db56a1bd18dd9c023c7bb3f">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_VERSION_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION_MINOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minor version number. </p>

</div>
</div>
<a id="ga323b74fa31dd5419b2eb9af6f04e49ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga323b74fa31dd5419b2eb9af6f04e49ef">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_VERSION <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total version number of the form <code>Mmm</code>. </p>

</div>
</div>
<a id="ga323b74fa31dd5419b2eb9af6f04e49ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga323b74fa31dd5419b2eb9af6f04e49ef">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_VERSION <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total version number of the form <code>Mmm</code>. </p>

</div>
</div>
<a id="gab9c74366ce94e4b30e7f8075fd46d3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c74366ce94e4b30e7f8075fd46d3c9">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_CHECK_ALLOCATION_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_CHECK_ALLOCATION_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the allocation size will be checked, i.e. </p>
<p>the bad_allocation_size thrown. </p>

</div>
</div>
<a id="gac8321c1ee9ddb2e5610249e39c79cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8321c1ee9ddb2e5610249e39c79cf5f">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_THREAD_SAFE_REFERENCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_THREAD_SAFE_REFERENCE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the <a class="el" href="group__core.html#gaee2f0e3847e0ab64384e5e8c8f1a7a27">foonathan::memory::default_mutex</a> will be <code>std::mutex</code> or <a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">foonathan::memory::no_mutex</a>. </p>

</div>
</div>
<a id="gadeca7ca88417f547b94c8013ee774665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeca7ca88417f547b94c8013ee774665">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_DEBUG_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_ASSERT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not internal assertions in the library are enabled. </p>

</div>
</div>
<a id="gaec921be38dec717ec1b6158672d445a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec921be38dec717ec1b6158672d445a5">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_DEBUG_FILL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_FILL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not allocated memory will be filled with special values. </p>

</div>
</div>
<a id="gaef525b4cee8ed9b5fb9c306fbcff9cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef525b4cee8ed9b5fb9c306fbcff9cda">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_DEBUG_FENCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_FENCE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the fence memory, it has no effect if <a class="el" href="group__core.html#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>false</code>. </p>
<dl class="section note"><dt>Note</dt><dd>For most allocators, the actual value doesn't matter and they use appropriate defaults to ensure alignment etc. </dd></dl>

</div>
</div>
<a id="ga56c19666f4d048ef6b5c2fd190228414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c19666f4d048ef6b5c2fd190228414">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not leak checking is enabled. </p>

</div>
</div>
<a id="ga77c494b053a54906e07e66779838a1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c494b053a54906e07e66779838a1b0">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the deallocation functions will check for pointers that were never allocated by an allocator. </p>

</div>
</div>
<a id="ga58e74e0d00f7dabde7e8cce1b67c8d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e74e0d00f7dabde7e8cce1b67c8d90">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the deallocation functions will check for double free errors. </p>
<p>This option makes no sense if <a class="el" href="group__core.html#ga77c494b053a54906e07e66779838a1b0">FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</a> is <code>false</code>. </p>

</div>
</div>
<a id="ga12fad87dece498b3fc56679b0906c336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12fad87dece498b3fc56679b0906c336">&#9670;&nbsp;</a></span>FOONATHAN_MEMORY_NAMESPACE_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_NAMESPACE_PREFIX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not everything is in namespace <code>foonathan::memory</code>. </p>
<p>If <code>false</code>, a namespace alias <code>namespace memory = foonathan::memory</code> is automatically inserted into each header, allowing to qualify everything with <code>foonathan::</code>. </p><dl class="section note"><dt>Note</dt><dd>This option breaks in combination with using <code>using namespace foonathan;</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedefs</h2>
<a id="gac9a31890ea6cb62d78938b43c9a496fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a31890ea6cb62d78938b43c9a496fa">&#9670;&nbsp;</a></span>leak_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> =  void (*)(const <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, std::ptrdiff_t amount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a memory leak is detected. </p>
<p>Leak checking can be controlled via the option <a class="el" href="group__core.html#ga56c19666f4d048ef6b5c2fd190228414">FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</a> and only affects calls through the <a class="el" href="classfoonathan_1_1memory_1_1allocator__traits.html">allocator_traits</a>, not direct calls. The handler gets the <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a> and the amount of memory leaked. This can also be negative, meaning that more memory has been freed than allocated. </p><dl class="section user"><dt>Required Behavior:\n A leak handler shall log the leak, abort the program, do nothing or anything else that seems appropriate.</dt><dd>It must not throw any exceptions since it is called in the cleanup process. </dd></dl>
<dl class="section user"><dt>Default Behavior:\n On a hosted implementation it logs the leak to <code>stderr</code> and returns, continuing execution.</dt><dd>On a freestanding implementation it does nothing. </dd></dl>

</div>
</div>
<a id="ga7055c92f3a0acf2f41d2090b7c1a5074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7055c92f3a0acf2f41d2090b7c1a5074">&#9670;&nbsp;</a></span>invalid_pointer_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> =  void (*)(const <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a>&amp; info, const void* ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when an invalid pointer is passed to a deallocation function. </p>
<p>Pointer checking can be controlled via the options <a class="el" href="group__core.html#ga77c494b053a54906e07e66779838a1b0">FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</a> and <a class="el" href="group__core.html#ga58e74e0d00f7dabde7e8cce1b67c8d90">FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a>. The handler gets the <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a> and the invalid pointer. </p><dl class="section user"><dt>Required Behavior:\n An invalid pointer handler shall terminate the program.</dt><dd>It must not throw any exceptions since it might be called in the cleanup process. </dd></dl>
<dl class="section user"><dt>Default Behavior:\n On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort</code>().</dt><dd>On a freestanding implementation it only calls <code>std::abort()</code>. </dd></dl>

</div>
</div>
<a id="ga055130bf52afd8d252a58ba57eb19799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga055130bf52afd8d252a58ba57eb19799">&#9670;&nbsp;</a></span>buffer_overflow_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a> =  void (*)(const void* memory, std::size_t size, const void* write_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a buffer under/overflow is detected. </p>
<p>If <a class="el" href="group__core.html#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>true</code> and <a class="el" href="group__core.html#gaef525b4cee8ed9b5fb9c306fbcff9cda">FOONATHAN_MEMORY_DEBUG_FENCE</a> has a non-zero value the allocator classes check if a write into the fence has occured upon deallocation. The handler gets the memory block belonging to the corrupted fence, its size and the exact address. </p><dl class="section user"><dt>Required Behavior:\n A buffer overflow handler shall terminate the program.</dt><dd>It must not throw any exceptions since it me be called in the cleanup process. </dd></dl>
<dl class="section user"><dt>Default Behavior:\n On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort</code>().</dt><dd>On a freestanding implementation it only calls <code>std::abort()</code>. </dd></dl>

</div>
</div>
<a id="gaf7651169a0cdd3612f5d8fc7baba505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7651169a0cdd3612f5d8fc7baba505b">&#9670;&nbsp;</a></span>make_block_allocator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a> =  implementation_defined</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes either a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> or a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>. </p>
<p>In the first case simply aliases the type unchanged, in the second to <a class="el" href="classfoonathan_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a> (or the template in <code>BlockAllocator</code>) with the <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>. Using this allows passing normal <a href="md_doc_concepts.html#concept_rawallocator">RawAllocators</a> as <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocators</a>. </p>

</div>
</div>
<a id="gaee2f0e3847e0ab64384e5e8c8f1a7a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2f0e3847e0ab64384e5e8c8f1a7a27">&#9670;&nbsp;</a></span>default_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__core.html#gaee2f0e3847e0ab64384e5e8c8f1a7a27">default_mutex</a> =  <a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">no_mutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default <code>Mutex</code> type used as default template paremeter in, e.g. </p>
<p><a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>. If the CMake option <a class="el" href="group__core.html#gac8321c1ee9ddb2e5610249e39c79cf5f">FOONATHAN_MEMORY_THREAD_SAFE_REFERENCE</a> is <code>true</code> and there is threading support, it is <code>std::mutex</code>, else <a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">no_mutex</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumerations</h2>
<a id="gab1db4d7ca0241d511710324c01f27b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1db4d7ca0241d511710324c01f27b23">&#9670;&nbsp;</a></span>debug_magic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__core.html#gab1db4d7ca0241d511710324c01f27b23">debug_magic</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The magic values that are used for debug filling. </p>
<p>If <a class="el" href="group__core.html#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>true</code>, memory will be filled to help detect use-after-free or missing initialization errors. These are the constants for the different types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a7bd4be20559c1a287369c8df4c117afe"></a>internal_memory&#160;</td><td class="fielddoc"><p>Marks internal memory used by the allocator - "allocated block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23aa5c32a0fcc06d646d53c71b55c9cf5cb"></a>internal_freed_memory&#160;</td><td class="fielddoc"><p>Marks internal memory currently not used by the allocator - "freed block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a9e1988b82181dbe51272459a8ac8e0c0"></a>new_memory&#160;</td><td class="fielddoc"><p>Marks allocated, but not yet used memory - "clean memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a635e5f9da5635b909461fd93c09130ed"></a>freed_memory&#160;</td><td class="fielddoc"><p>Marks freed memory - "dead memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a682318fff515ed43a48b718f46c21308"></a>alignment_memory&#160;</td><td class="fielddoc"><p>Marks buffer memory used to ensure proper alignment. </p>
<p>This memory can also serve as <a class="el" href="group__core.html#ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360">debug_magic::fence_memory</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360"></a>fence_memory&#160;</td><td class="fielddoc"><p>Marks buffer memory used to protect against overflow - "fence memory". </p>
<p>The option <a class="el" href="group__core.html#gaef525b4cee8ed9b5fb9c306fbcff9cda">FOONATHAN_MEMORY_DEBUG_FENCE</a> controls the size of a memory fence that will be placed before or after a memory block. It helps catching buffer overflows. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Functions</h2>
<a id="gac5415329fb8f760eed33cb0f9a8eaed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5415329fb8f760eed33cb0f9a8eaed5">&#9670;&nbsp;</a></span>set_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> foonathan::memory::set_leak_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. </p>
<dl class="section user"><dt>Effects:\n Sets <code>h</code> as the new \ref leak_handler in an atomic operation.</dt><dd>A <code>nullptr</code> sets the default <a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. </dd></dl>
<dl class="section user"><dt>Returns:\n The previous \ref leak_handler. This is never <code>nullptr</code>.</dt><dd></dd></dl>

</div>
</div>
<a id="ga32882ffa8bd8feafe3334e7b9b6ca8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32882ffa8bd8feafe3334e7b9b6ca8c6">&#9670;&nbsp;</a></span>get_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> foonathan::memory::get_leak_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__core.html#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. </p>
<dl class="section user"><dt>Returns:\n The current \ref leak_handler. This is never <code>nullptr</code>.</dt><dd></dd></dl>

</div>
</div>
<a id="gad22a929516dd5a2e9e326f2c5c8326df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad22a929516dd5a2e9e326f2c5c8326df">&#9670;&nbsp;</a></span>set_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> foonathan::memory::set_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt>Effects:\n Sets <code>h</code> as the new \ref invalid_pointer_handler in an atomic operation.</dt><dd>A <code>nullptr</code> sets the default <a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. </dd></dl>
<dl class="section user"><dt>Returns:\n The previous \ref invalid_pointer_handler. This is never <code>nullptr</code>.</dt><dd></dd></dl>

</div>
</div>
<a id="gac3fa468c245a855bb39074df3d74ff95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3fa468c245a855bb39074df3d74ff95">&#9670;&nbsp;</a></span>get_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> foonathan::memory::get_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__core.html#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt>Returns:\n The current \ref invalid_pointer_handler. This is never <code>nullptr</code>.</dt><dd></dd></dl>

</div>
</div>
<a id="gad786a5a56d768a5be1e13a769ea19f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad786a5a56d768a5be1e13a769ea19f74">&#9670;&nbsp;</a></span>set_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a> foonathan::memory::set_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt>Effects:\n Sets <code>h</code> as the new \ref buffer_overflow_handler in an atomic operation.</dt><dd>A <code>nullptr</code> sets the default <a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>. </dd></dl>
<dl class="section user"><dt>Returns:\n The previous \ref buffer_overflow_handler. This is never <code>nullptr</code>.</dt><dd></dd></dl>

</div>
</div>
<a id="ga7f6771bda16c1cd6da0c456c28415774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f6771bda16c1cd6da0c456c28415774">&#9670;&nbsp;</a></span>get_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a> foonathan::memory::get_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__core.html#ga055130bf52afd8d252a58ba57eb19799">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt>Returns:\n The current \ref buffer_overflow_handler. This is never <code>nullptr</code>.</dt><dd></dd></dl>

</div>
</div>
<a id="ga5c1e85082887bdf9000fbaf5f6138a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1e85082887bdf9000fbaf5f6138a61">&#9670;&nbsp;</a></span>make_block_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a>&lt;BlockOrRawAllocator&gt; foonathan::memory::make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function make a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </p><dl class="section user"><dt>Returns:\n A BlockAllocator of the given type created with the given arguments.</dt><dd></dd></dl>
<dl class="section user"><dt>Requires:\n Same requirements as the constructor.</dt><dd></dd></dl>

</div>
</div>
<a id="ga70667a30ead35eaee18f32c3b3e1db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70667a30ead35eaee18f32c3b3e1db6c">&#9670;&nbsp;</a></span>make_block_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core.html#gaf7651169a0cdd3612f5d8fc7baba505b">make_block_allocator_t</a>&lt;BlockOrRawAllocator, BlockAllocator&gt; foonathan::memory::make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function make a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </p><dl class="section user"><dt>Returns:\n A BlockAllocator of the given type created with the given arguments.</dt><dd></dd></dl>
<dl class="section user"><dt>Requires:\n Same requirements as the constructor.</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5cc824b77744b3bc5074b71c252b8f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc824b77744b3bc5074b71c252b8f81">&#9670;&nbsp;</a></span>cached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cached_arena</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls the caching of <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>. By default, deallocated blocks are put onto a cache, so they can be reused later; this tag value enable/disable it..<br  />
 This can be useful, e.g. if there will never be blocks available for deallocation. The (tiny) overhead for the cache can then be disabled. An example is memory_pool. </p>

</div>
</div>
<a id="ga1b5ff9c47c6c768c7d5b9937f4df2434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b5ff9c47c6c768c7d5b9937f4df2434">&#9670;&nbsp;</a></span>uncached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool uncached_arena</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls the caching of <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>. By default, deallocated blocks are put onto a cache, so they can be reused later; this tag value enable/disable it..<br  />
 This can be useful, e.g. if there will never be blocks available for deallocation. The (tiny) overhead for the cache can then be disabled. An example is memory_pool. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
