<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: Core components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Core components</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class that checks whether or not a standard <code>Allocator</code> can be used as <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html">allocator_is_raw_allocator&lt; std::allocator&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator.html">allocator_is_raw_allocator</a> that allows <code>std::allocator</code> again.  <a href="structfoonathan_1_1memory_1_1allocator__is__raw__allocator_3_01std_1_1allocator_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__traits.html">allocator_traits&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the allocator_traits for a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="classfoonathan_1_1memory_1_1allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__raw__allocator.html">is_raw_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <a href="structfoonathan_1_1memory_1_1is__raw__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1composable__allocator__traits.html">composable_allocator_traits&lt; Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default specialization of the composable_allocator_traits for a <a href="md_doc_concepts.html#concept_composableallocator">ComposableAllocator</a>.  <a href="classfoonathan_1_1memory_1_1composable__allocator__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__composable__allocator.html">is_composable_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept <a href="md_doc_concepts.html#concept_rawallocator">ComposableAllocator</a>.  <a href="structfoonathan_1_1memory_1_1is__composable__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains information about an allocator.  <a href="structfoonathan_1_1memory_1_1allocator__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1out__of__memory.html">out_of_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when a low level allocator runs out of memory.  <a href="classfoonathan_1_1memory_1_1out__of__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1out__of__fixed__memory.html">out_of_fixed_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="classfoonathan_1_1memory_1_1out__of__memory.html">out_of_memory</a> errors thrown when a low-level allocator with a fixed size runs out of memory.  <a href="classfoonathan_1_1memory_1_1out__of__fixed__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when an allocation size is bigger than the supported maximum.  <a href="classfoonathan_1_1memory_1_1bad__allocation__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__node__size.html">bad_node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the node size exceeds the supported maximum, i.e.  <a href="classfoonathan_1_1memory_1_1bad__node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__array__size.html">bad_array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the array size exceeds the supported maximum, i.e.  <a href="classfoonathan_1_1memory_1_1bad__array__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1bad__alignment.html">bad_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception class thrown when the alignment exceeds the supported maximum, i.e.  <a href="classfoonathan_1_1memory_1_1bad__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory block.  <a href="structfoonathan_1_1memory_1_1memory__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__block__allocator.html">is_block_allocator&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits that check whether a type models concept <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>.  <a href="structfoonathan_1_1memory_1_1is__block__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena&lt; BlockAllocator, Cached &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena that manages huge memory blocks for a higher-level allocator.  <a href="classfoonathan_1_1memory_1_1memory__arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1no__mutex.html">no_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy <code>Mutex</code> class that does not lock anything.  <a href="structfoonathan_1_1memory_1_1no__mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfoonathan_1_1memory_1_1is__thread__safe__allocator.html">is_thread_safe_allocator&lt; RawAllocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether or not a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a> is thread safe as-is.  <a href="structfoonathan_1_1memory_1_1is__thread__safe__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga57ff31908827db59ce4900bd636ed1d8" id="r_ga57ff31908827db59ce4900bd636ed1d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga57ff31908827db59ce4900bd636ed1d8">FOONATHAN_MEMORY_VERSION_MAJOR</a></td></tr>
<tr class="memdesc:ga57ff31908827db59ce4900bd636ed1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The major version number.  <br /></td></tr>
<tr class="separator:ga57ff31908827db59ce4900bd636ed1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c78c0886db56a1bd18dd9c023c7bb3f" id="r_ga1c78c0886db56a1bd18dd9c023c7bb3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c78c0886db56a1bd18dd9c023c7bb3f">FOONATHAN_MEMORY_VERSION_MINOR</a></td></tr>
<tr class="memdesc:ga1c78c0886db56a1bd18dd9c023c7bb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minor version number.  <br /></td></tr>
<tr class="separator:ga1c78c0886db56a1bd18dd9c023c7bb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323b74fa31dd5419b2eb9af6f04e49ef" id="r_ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga323b74fa31dd5419b2eb9af6f04e49ef">FOONATHAN_MEMORY_VERSION</a></td></tr>
<tr class="memdesc:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total version number of the form <code>Mmm</code>.  <br /></td></tr>
<tr class="separator:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323b74fa31dd5419b2eb9af6f04e49ef" id="r_ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga323b74fa31dd5419b2eb9af6f04e49ef">FOONATHAN_MEMORY_VERSION</a></td></tr>
<tr class="memdesc:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total version number of the form <code>Mmm</code>.  <br /></td></tr>
<tr class="separator:ga323b74fa31dd5419b2eb9af6f04e49ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c74366ce94e4b30e7f8075fd46d3c9" id="r_gab9c74366ce94e4b30e7f8075fd46d3c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9c74366ce94e4b30e7f8075fd46d3c9">FOONATHAN_MEMORY_CHECK_ALLOCATION_SIZE</a></td></tr>
<tr class="memdesc:gab9c74366ce94e4b30e7f8075fd46d3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the allocation size will be checked, i.e.  <br /></td></tr>
<tr class="separator:gab9c74366ce94e4b30e7f8075fd46d3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeca7ca88417f547b94c8013ee774665" id="r_gadeca7ca88417f547b94c8013ee774665"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadeca7ca88417f547b94c8013ee774665">FOONATHAN_MEMORY_DEBUG_ASSERT</a></td></tr>
<tr class="memdesc:gadeca7ca88417f547b94c8013ee774665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not internal assertions in the library are enabled.  <br /></td></tr>
<tr class="separator:gadeca7ca88417f547b94c8013ee774665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec921be38dec717ec1b6158672d445a5" id="r_gaec921be38dec717ec1b6158672d445a5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a></td></tr>
<tr class="memdesc:gaec921be38dec717ec1b6158672d445a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not allocated memory will be filled with special values.  <br /></td></tr>
<tr class="separator:gaec921be38dec717ec1b6158672d445a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef525b4cee8ed9b5fb9c306fbcff9cda" id="r_gaef525b4cee8ed9b5fb9c306fbcff9cda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaef525b4cee8ed9b5fb9c306fbcff9cda">FOONATHAN_MEMORY_DEBUG_FENCE</a></td></tr>
<tr class="memdesc:gaef525b4cee8ed9b5fb9c306fbcff9cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the fence memory, it has no effect if <a class="el" href="#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>false</code>.  <br /></td></tr>
<tr class="separator:gaef525b4cee8ed9b5fb9c306fbcff9cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c19666f4d048ef6b5c2fd190228414" id="r_ga56c19666f4d048ef6b5c2fd190228414"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga56c19666f4d048ef6b5c2fd190228414">FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</a></td></tr>
<tr class="memdesc:ga56c19666f4d048ef6b5c2fd190228414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not leak checking is enabled.  <br /></td></tr>
<tr class="separator:ga56c19666f4d048ef6b5c2fd190228414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c494b053a54906e07e66779838a1b0" id="r_ga77c494b053a54906e07e66779838a1b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77c494b053a54906e07e66779838a1b0">FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</a></td></tr>
<tr class="memdesc:ga77c494b053a54906e07e66779838a1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the deallocation functions will check for pointers that were never allocated by an allocator.  <br /></td></tr>
<tr class="separator:ga77c494b053a54906e07e66779838a1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e74e0d00f7dabde7e8cce1b67c8d90" id="r_ga58e74e0d00f7dabde7e8cce1b67c8d90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58e74e0d00f7dabde7e8cce1b67c8d90">FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a></td></tr>
<tr class="memdesc:ga58e74e0d00f7dabde7e8cce1b67c8d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the deallocation functions will check for double free errors.  <br /></td></tr>
<tr class="separator:ga58e74e0d00f7dabde7e8cce1b67c8d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fad87dece498b3fc56679b0906c336" id="r_ga12fad87dece498b3fc56679b0906c336"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga12fad87dece498b3fc56679b0906c336">FOONATHAN_MEMORY_NAMESPACE_PREFIX</a></td></tr>
<tr class="memdesc:ga12fad87dece498b3fc56679b0906c336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not everything is in namespace <code>foonathan::memory</code>.  <br /></td></tr>
<tr class="separator:ga12fad87dece498b3fc56679b0906c336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac9a31890ea6cb62d78938b43c9a496fa" id="r_gac9a31890ea6cb62d78938b43c9a496fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a></td></tr>
<tr class="memdesc:gac9a31890ea6cb62d78938b43c9a496fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a memory leak is detected.  <br /></td></tr>
<tr class="separator:gac9a31890ea6cb62d78938b43c9a496fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7055c92f3a0acf2f41d2090b7c1a5074" id="r_ga7055c92f3a0acf2f41d2090b7c1a5074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a></td></tr>
<tr class="memdesc:ga7055c92f3a0acf2f41d2090b7c1a5074"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when an invalid pointer is passed to a deallocation function.  <br /></td></tr>
<tr class="separator:ga7055c92f3a0acf2f41d2090b7c1a5074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75bb91055f3fdd404385935cc7dc85f2" id="r_ga75bb91055f3fdd404385935cc7dc85f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a></td></tr>
<tr class="memdesc:ga75bb91055f3fdd404385935cc7dc85f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the handler called when a buffer under/overflow is detected.  <br /></td></tr>
<tr class="separator:ga75bb91055f3fdd404385935cc7dc85f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7837ffc0461e5e9bb3a92f62c7c1de9d" id="r_ga7837ffc0461e5e9bb3a92f62c7c1de9d"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator, template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </td></tr>
<tr class="memitem:ga7837ffc0461e5e9bb3a92f62c7c1de9d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">make_block_allocator_t</a></td></tr>
<tr class="memdesc:ga7837ffc0461e5e9bb3a92f62c7c1de9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes either a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> or a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>.  <br /></td></tr>
<tr class="separator:ga7837ffc0461e5e9bb3a92f62c7c1de9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gab1db4d7ca0241d511710324c01f27b23" id="r_gab1db4d7ca0241d511710324c01f27b23"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1db4d7ca0241d511710324c01f27b23">debug_magic</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23a7bd4be20559c1a287369c8df4c117afe">internal_memory</a>
, <a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23aa5c32a0fcc06d646d53c71b55c9cf5cb">internal_freed_memory</a>
, <a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23a9e1988b82181dbe51272459a8ac8e0c0">new_memory</a>
, <a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23a635e5f9da5635b909461fd93c09130ed">freed_memory</a>
, <br />
&#160;&#160;<a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23a682318fff515ed43a48b718f46c21308">alignment_memory</a>
, <a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360">fence_memory</a>
<br />
 }</td></tr>
<tr class="memdesc:gab1db4d7ca0241d511710324c01f27b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The magic values that are used for debug filling.  <a href="#gab1db4d7ca0241d511710324c01f27b23">More...</a><br /></td></tr>
<tr class="separator:gab1db4d7ca0241d511710324c01f27b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae4453121bb970591b7f481d03d7d527a" id="r_gae4453121bb970591b7f481d03d7d527a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4453121bb970591b7f481d03d7d527a">set_leak_handler</a> (<a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> h)</td></tr>
<tr class="memdesc:gae4453121bb970591b7f481d03d7d527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>.  <br /></td></tr>
<tr class="separator:gae4453121bb970591b7f481d03d7d527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f4eff5707aabf7e99bdbf3b13f504cf" id="r_ga5f4eff5707aabf7e99bdbf3b13f504cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f4eff5707aabf7e99bdbf3b13f504cf">get_leak_handler</a> ()</td></tr>
<tr class="memdesc:ga5f4eff5707aabf7e99bdbf3b13f504cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>.  <br /></td></tr>
<tr class="separator:ga5f4eff5707aabf7e99bdbf3b13f504cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga209376587082a7d9961a98f3b6ec7dcc" id="r_ga209376587082a7d9961a98f3b6ec7dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga209376587082a7d9961a98f3b6ec7dcc">set_invalid_pointer_handler</a> (<a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> h)</td></tr>
<tr class="memdesc:ga209376587082a7d9961a98f3b6ec7dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>.  <br /></td></tr>
<tr class="separator:ga209376587082a7d9961a98f3b6ec7dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e65dc3167005dae3555309f60ed513c" id="r_ga2e65dc3167005dae3555309f60ed513c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e65dc3167005dae3555309f60ed513c">get_invalid_pointer_handler</a> ()</td></tr>
<tr class="memdesc:ga2e65dc3167005dae3555309f60ed513c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>.  <br /></td></tr>
<tr class="separator:ga2e65dc3167005dae3555309f60ed513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75ea0aa3407c219d791599f57816f11d" id="r_ga75ea0aa3407c219d791599f57816f11d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga75ea0aa3407c219d791599f57816f11d">set_buffer_overflow_handler</a> (<a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a> h)</td></tr>
<tr class="memdesc:ga75ea0aa3407c219d791599f57816f11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>.  <br /></td></tr>
<tr class="separator:ga75ea0aa3407c219d791599f57816f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0074cf9355edffd97fb462705a8ddb4" id="r_gaf0074cf9355edffd97fb462705a8ddb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0074cf9355edffd97fb462705a8ddb4">get_buffer_overflow_handler</a> ()</td></tr>
<tr class="memdesc:gaf0074cf9355edffd97fb462705a8ddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>.  <br /></td></tr>
<tr class="separator:gaf0074cf9355edffd97fb462705a8ddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc824b77744b3bc5074b71c252b8f81" id="r_ga5cc824b77744b3bc5074b71c252b8f81"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5cc824b77744b3bc5074b71c252b8f81">cached_arena</a></td></tr>
<tr class="separator:ga5cc824b77744b3bc5074b71c252b8f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5ff9c47c6c768c7d5b9937f4df2434" id="r_ga1b5ff9c47c6c768c7d5b9937f4df2434"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b5ff9c47c6c768c7d5b9937f4df2434">uncached_arena</a></td></tr>
<tr class="separator:ga1b5ff9c47c6c768c7d5b9937f4df2434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9cd3447e8a456f790a7f85a08b47ca5" id="r_gab9cd3447e8a456f790a7f85a08b47ca5"><td class="memTemplParams" colspan="2">template&lt;class BlockOrRawAllocator, typename... Args&gt; </td></tr>
<tr class="memitem:gab9cd3447e8a456f790a7f85a08b47ca5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#gab9cd3447e8a456f790a7f85a08b47ca5">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:gab9cd3447e8a456f790a7f85a08b47ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27983f6c819df4a260f596e23c491ff2" id="r_ga27983f6c819df4a260f596e23c491ff2"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator, typename... Args&gt; </td></tr>
<tr class="memitem:ga27983f6c819df4a260f596e23c491ff2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ga27983f6c819df4a260f596e23c491ff2">make_block_allocator</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga27983f6c819df4a260f596e23c491ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd98417bee6c1710ef6c8d9ae84ba56" id="r_ga1dd98417bee6c1710ef6c8d9ae84ba56"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1dd98417bee6c1710ef6c8d9ae84ba56">operator&quot;&quot;_KiB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:ga1dd98417bee6c1710ef6c8d9ae84ba56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:ga1dd98417bee6c1710ef6c8d9ae84ba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1899fc96b11ad594e641360febc41543" id="r_ga1899fc96b11ad594e641360febc41543"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1899fc96b11ad594e641360febc41543">operator&quot;&quot;_KB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:ga1899fc96b11ad594e641360febc41543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:ga1899fc96b11ad594e641360febc41543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b65aecdd2e2e777031cfb648c0dc779" id="r_ga6b65aecdd2e2e777031cfb648c0dc779"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b65aecdd2e2e777031cfb648c0dc779">operator&quot;&quot;_MiB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:ga6b65aecdd2e2e777031cfb648c0dc779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:ga6b65aecdd2e2e777031cfb648c0dc779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1931c0327c77d374f6c2fab637f6aa31" id="r_ga1931c0327c77d374f6c2fab637f6aa31"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1931c0327c77d374f6c2fab637f6aa31">operator&quot;&quot;_MB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:ga1931c0327c77d374f6c2fab637f6aa31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:ga1931c0327c77d374f6c2fab637f6aa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72a54307073160e72c67724e3c83a454" id="r_ga72a54307073160e72c67724e3c83a454"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga72a54307073160e72c67724e3c83a454">operator&quot;&quot;_GiB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:ga72a54307073160e72c67724e3c83a454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:ga72a54307073160e72c67724e3c83a454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b4362f43a9bf8e339eae1b7ea6c57e" id="r_ga97b4362f43a9bf8e339eae1b7ea6c57e"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga97b4362f43a9bf8e339eae1b7ea6c57e">operator&quot;&quot;_GB</a> (unsigned long long value) noexcept</td></tr>
<tr class="memdesc:ga97b4362f43a9bf8e339eae1b7ea6c57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntax sugar to express sizes with unit prefixes.  <br /></td></tr>
<tr class="separator:ga97b4362f43a9bf8e339eae1b7ea6c57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Defines</h2>
<a id="ga57ff31908827db59ce4900bd636ed1d8" name="ga57ff31908827db59ce4900bd636ed1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57ff31908827db59ce4900bd636ed1d8">&#9670;&#160;</a></span>FOONATHAN_MEMORY_VERSION_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION_MAJOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The major version number. </p>

</div>
</div>
<a id="ga1c78c0886db56a1bd18dd9c023c7bb3f" name="ga1c78c0886db56a1bd18dd9c023c7bb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c78c0886db56a1bd18dd9c023c7bb3f">&#9670;&#160;</a></span>FOONATHAN_MEMORY_VERSION_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION_MINOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minor version number. </p>

</div>
</div>
<a id="ga323b74fa31dd5419b2eb9af6f04e49ef" name="ga323b74fa31dd5419b2eb9af6f04e49ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga323b74fa31dd5419b2eb9af6f04e49ef">&#9670;&#160;</a></span>FOONATHAN_MEMORY_VERSION <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total version number of the form <code>Mmm</code>. </p>

</div>
</div>
<a id="ga323b74fa31dd5419b2eb9af6f04e49ef" name="ga323b74fa31dd5419b2eb9af6f04e49ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga323b74fa31dd5419b2eb9af6f04e49ef">&#9670;&#160;</a></span>FOONATHAN_MEMORY_VERSION <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_VERSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total version number of the form <code>Mmm</code>. </p>

</div>
</div>
<a id="gab9c74366ce94e4b30e7f8075fd46d3c9" name="gab9c74366ce94e4b30e7f8075fd46d3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c74366ce94e4b30e7f8075fd46d3c9">&#9670;&#160;</a></span>FOONATHAN_MEMORY_CHECK_ALLOCATION_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_CHECK_ALLOCATION_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the allocation size will be checked, i.e. </p>
<p>the <a class="el" href="classfoonathan_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a> thrown. </p>

</div>
</div>
<a id="gadeca7ca88417f547b94c8013ee774665" name="gadeca7ca88417f547b94c8013ee774665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeca7ca88417f547b94c8013ee774665">&#9670;&#160;</a></span>FOONATHAN_MEMORY_DEBUG_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_ASSERT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not internal assertions in the library are enabled. </p>

</div>
</div>
<a id="gaec921be38dec717ec1b6158672d445a5" name="gaec921be38dec717ec1b6158672d445a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec921be38dec717ec1b6158672d445a5">&#9670;&#160;</a></span>FOONATHAN_MEMORY_DEBUG_FILL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_FILL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not allocated memory will be filled with special values. </p>

</div>
</div>
<a id="gaef525b4cee8ed9b5fb9c306fbcff9cda" name="gaef525b4cee8ed9b5fb9c306fbcff9cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef525b4cee8ed9b5fb9c306fbcff9cda">&#9670;&#160;</a></span>FOONATHAN_MEMORY_DEBUG_FENCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_FENCE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the fence memory, it has no effect if <a class="el" href="#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>false</code>. </p>
<dl class="section note"><dt>Note</dt><dd>For most allocators, the actual value doesn't matter and they use appropriate defaults to ensure alignment etc. </dd></dl>

</div>
</div>
<a id="ga56c19666f4d048ef6b5c2fd190228414" name="ga56c19666f4d048ef6b5c2fd190228414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c19666f4d048ef6b5c2fd190228414">&#9670;&#160;</a></span>FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not leak checking is enabled. </p>

</div>
</div>
<a id="ga77c494b053a54906e07e66779838a1b0" name="ga77c494b053a54906e07e66779838a1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c494b053a54906e07e66779838a1b0">&#9670;&#160;</a></span>FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the deallocation functions will check for pointers that were never allocated by an allocator. </p>

</div>
</div>
<a id="ga58e74e0d00f7dabde7e8cce1b67c8d90" name="ga58e74e0d00f7dabde7e8cce1b67c8d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e74e0d00f7dabde7e8cce1b67c8d90">&#9670;&#160;</a></span>FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not the deallocation functions will check for double free errors. </p>
<p>This option makes no sense if <a class="el" href="#ga77c494b053a54906e07e66779838a1b0">FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</a> is <code>false</code>. </p>

</div>
</div>
<a id="ga12fad87dece498b3fc56679b0906c336" name="ga12fad87dece498b3fc56679b0906c336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12fad87dece498b3fc56679b0906c336">&#9670;&#160;</a></span>FOONATHAN_MEMORY_NAMESPACE_PREFIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOONATHAN_MEMORY_NAMESPACE_PREFIX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not everything is in namespace <code>foonathan::memory</code>. </p>
<p>If <code>false</code>, a namespace alias <code>namespace memory = foonathan::memory</code> is automatically inserted into each header, allowing to qualify everything with <code>foonathan::</code>. </p><dl class="section note"><dt>Note</dt><dd>This option breaks in combination with using <code>using namespace foonathan;</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedefs</h2>
<a id="gac9a31890ea6cb62d78938b43c9a496fa" name="gac9a31890ea6cb62d78938b43c9a496fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a31890ea6cb62d78938b43c9a496fa">&#9670;&#160;</a></span>leak_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a memory leak is detected. </p>
<p>Leak checking can be controlled via the option <a class="el" href="#ga56c19666f4d048ef6b5c2fd190228414">FOONATHAN_MEMORY_DEBUG_LEAK_CHECK</a> and only affects calls through the <a class="el" href="classfoonathan_1_1memory_1_1allocator__traits.html">allocator_traits</a>, not direct calls. The handler gets the <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a> and the amount of memory leaked. This can also be negative, meaning that more memory has been freed than allocated. </p><dl class="section user"><dt><em>Required Behavior:</em></dt><dd>A leak handler shall log the leak, abort the program, do nothing or anything else that seems appropriate. It must not throw any exceptions since it is called in the cleanup process. </dd></dl>
<dl class="section user"><dt><em>Default Behavior:</em></dt><dd>On a hosted implementation it logs the leak to <code>stderr</code> and returns, continuing execution. On a freestanding implementation it does nothing. </dd></dl>

</div>
</div>
<a id="ga7055c92f3a0acf2f41d2090b7c1a5074" name="ga7055c92f3a0acf2f41d2090b7c1a5074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7055c92f3a0acf2f41d2090b7c1a5074">&#9670;&#160;</a></span>invalid_pointer_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when an invalid pointer is passed to a deallocation function. </p>
<p>Pointer checking can be controlled via the options <a class="el" href="#ga77c494b053a54906e07e66779838a1b0">FOONATHAN_MEMORY_DEBUG_POINTER_CHECK</a> and <a class="el" href="#ga58e74e0d00f7dabde7e8cce1b67c8d90">FOONATHAN_MEMORY_DEBUG_DOUBLE_DEALLOC_CHECK</a>. The handler gets the <a class="el" href="structfoonathan_1_1memory_1_1allocator__info.html">allocator_info</a> and the invalid pointer. </p><dl class="section user"><dt><em>Required Behavior:</em></dt><dd>An invalid pointer handler shall terminate the program. It must not throw any exceptions since it might be called in the cleanup process. </dd></dl>
<dl class="section user"><dt><em>Default Behavior:</em></dt><dd>On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort()</code>. On a freestanding implementation it only calls <code>std::abort()</code>. </dd></dl>

</div>
</div>
<a id="ga75bb91055f3fdd404385935cc7dc85f2" name="ga75bb91055f3fdd404385935cc7dc85f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75bb91055f3fdd404385935cc7dc85f2">&#9670;&#160;</a></span>buffer_overflow_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the handler called when a buffer under/overflow is detected. </p>
<p>If <a class="el" href="#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>true</code> and <a class="el" href="#gaef525b4cee8ed9b5fb9c306fbcff9cda">FOONATHAN_MEMORY_DEBUG_FENCE</a> has a non-zero value the allocator classes check if a write into the fence has occured upon deallocation. The handler gets the memory block belonging to the corrupted fence, its size and the exact address. </p><dl class="section user"><dt><em>Required Behavior:</em></dt><dd>A buffer overflow handler shall terminate the program. It must not throw any exceptions since it me be called in the cleanup process. </dd></dl>
<dl class="section user"><dt><em>Default Behavior:</em></dt><dd>On a hosted implementation it logs the information to <code>stderr</code> and calls <code>std::abort()</code>. On a freestanding implementation it only calls <code>std::abort()</code>. </dd></dl>

</div>
</div>
<a id="ga7837ffc0461e5e9bb3a92f62c7c1de9d" name="ga7837ffc0461e5e9bb3a92f62c7c1de9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">&#9670;&#160;</a></span>make_block_allocator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator, template&lt; typename... &gt; class BlockAllocator = detail::default_block_wrapper&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">make_block_allocator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes either a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> or a <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>. </p>
<p>In the first case simply aliases the type unchanged, in the second to <a class="el" href="classfoonathan_1_1memory_1_1growing__block__allocator.html">growing_block_allocator</a> (or the template in <code>BlockAllocator</code>) with the <a href="md_doc_concepts.html#concept_rawallocator">RawAllocator</a>. Using this allows passing normal <a href="md_doc_concepts.html#concept_rawallocator">RawAllocators</a> as <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocators</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumerations</h2>
<a id="gab1db4d7ca0241d511710324c01f27b23" name="gab1db4d7ca0241d511710324c01f27b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1db4d7ca0241d511710324c01f27b23">&#9670;&#160;</a></span>debug_magic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#gab1db4d7ca0241d511710324c01f27b23">debug_magic</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The magic values that are used for debug filling. </p>
<p>If <a class="el" href="#gaec921be38dec717ec1b6158672d445a5">FOONATHAN_MEMORY_DEBUG_FILL</a> is <code>true</code>, memory will be filled to help detect use-after-free or missing initialization errors. These are the constants for the different types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a7bd4be20559c1a287369c8df4c117afe" name="ggab1db4d7ca0241d511710324c01f27b23a7bd4be20559c1a287369c8df4c117afe"></a>internal_memory&#160;</td><td class="fielddoc"><p>Marks internal memory used by the allocator - "allocated block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23aa5c32a0fcc06d646d53c71b55c9cf5cb" name="ggab1db4d7ca0241d511710324c01f27b23aa5c32a0fcc06d646d53c71b55c9cf5cb"></a>internal_freed_memory&#160;</td><td class="fielddoc"><p>Marks internal memory currently not used by the allocator - "freed block". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a9e1988b82181dbe51272459a8ac8e0c0" name="ggab1db4d7ca0241d511710324c01f27b23a9e1988b82181dbe51272459a8ac8e0c0"></a>new_memory&#160;</td><td class="fielddoc"><p>Marks allocated, but not yet used memory - "clean memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a635e5f9da5635b909461fd93c09130ed" name="ggab1db4d7ca0241d511710324c01f27b23a635e5f9da5635b909461fd93c09130ed"></a>freed_memory&#160;</td><td class="fielddoc"><p>Marks freed memory - "dead memory". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a682318fff515ed43a48b718f46c21308" name="ggab1db4d7ca0241d511710324c01f27b23a682318fff515ed43a48b718f46c21308"></a>alignment_memory&#160;</td><td class="fielddoc"><p>Marks buffer memory used to ensure proper alignment. </p>
<p>This memory can also serve as <a class="el" href="#ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360">fence_memory</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360" name="ggab1db4d7ca0241d511710324c01f27b23a99ec421b05ddc9b5565897f6a0cfb360"></a>fence_memory&#160;</td><td class="fielddoc"><p>Marks buffer memory used to protect against overflow - "fence memory". </p>
<p>The option <a class="el" href="#gaef525b4cee8ed9b5fb9c306fbcff9cda">FOONATHAN_MEMORY_DEBUG_FENCE</a> controls the size of a memory fence that will be placed before or after a memory block. It helps catching buffer overflows. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Functions</h2>
<a id="gae4453121bb970591b7f481d03d7d527a" name="gae4453121bb970591b7f481d03d7d527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4453121bb970591b7f481d03d7d527a">&#9670;&#160;</a></span>set_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> set_leak_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a></td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. </p>
<dl class="section user"><dt><em>Effects:</em></dt><dd>Sets <code>h</code> as the new <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The previous <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga5f4eff5707aabf7e99bdbf3b13f504cf" name="ga5f4eff5707aabf7e99bdbf3b13f504cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f4eff5707aabf7e99bdbf3b13f504cf">&#9670;&#160;</a></span>get_leak_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a> get_leak_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current <a class="el" href="#gac9a31890ea6cb62d78938b43c9a496fa">leak_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga209376587082a7d9961a98f3b6ec7dcc" name="ga209376587082a7d9961a98f3b6ec7dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga209376587082a7d9961a98f3b6ec7dcc">&#9670;&#160;</a></span>set_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> set_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a></td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt><em>Effects:</em></dt><dd>Sets <code>h</code> as the new <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The previous <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga2e65dc3167005dae3555309f60ed513c" name="ga2e65dc3167005dae3555309f60ed513c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e65dc3167005dae3555309f60ed513c">&#9670;&#160;</a></span>get_invalid_pointer_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a> get_invalid_pointer_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current <a class="el" href="#ga7055c92f3a0acf2f41d2090b7c1a5074">invalid_pointer_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="ga75ea0aa3407c219d791599f57816f11d" name="ga75ea0aa3407c219d791599f57816f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75ea0aa3407c219d791599f57816f11d">&#9670;&#160;</a></span>set_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a> set_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a></td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt><em>Effects:</em></dt><dd>Sets <code>h</code> as the new <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a> in an atomic operation. A <code>nullptr</code> sets the default <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The previous <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gaf0074cf9355edffd97fb462705a8ddb4" name="gaf0074cf9355edffd97fb462705a8ddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0074cf9355edffd97fb462705a8ddb4">&#9670;&#160;</a></span>get_buffer_overflow_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a> get_buffer_overflow_handler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current <a class="el" href="#ga75bb91055f3fdd404385935cc7dc85f2">buffer_overflow_handler</a>. This is never <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="gab9cd3447e8a456f790a7f85a08b47ca5" name="gab9cd3447e8a456f790a7f85a08b47ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9cd3447e8a456f790a7f85a08b47ca5">&#9670;&#160;</a></span>make_block_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockOrRawAllocator, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">make_block_allocator_t</a>&lt; BlockOrRawAllocator &gt; make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function make a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </p><dl class="section user"><dt><em>Returns:</em></dt><dd>A <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> of the given type created with the given arguments. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>Same requirements as the constructor. </dd></dl>

</div>
</div>
<a id="ga1dd98417bee6c1710ef6c8d9ae84ba56" name="ga1dd98417bee6c1710ef6c8d9ae84ba56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd98417bee6c1710ef6c8d9ae84ba56">&#9670;&#160;</a></span>operator&quot;&quot;_KiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t operator&quot;&quot;_KiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga27983f6c819df4a260f596e23c491ff2" name="ga27983f6c819df4a260f596e23c491ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27983f6c819df4a260f596e23c491ff2">&#9670;&#160;</a></span>make_block_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class BlockAllocator, class BlockOrRawAllocator, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga7837ffc0461e5e9bb3a92f62c7c1de9d">make_block_allocator_t</a>&lt; BlockOrRawAllocator, BlockAllocator &gt; make_block_allocator </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function make a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </p><dl class="section user"><dt><em>Returns:</em></dt><dd>A <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> of the given type created with the given arguments. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>Same requirements as the constructor. </dd></dl>

</div>
</div>
<a id="ga1899fc96b11ad594e641360febc41543" name="ga1899fc96b11ad594e641360febc41543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1899fc96b11ad594e641360febc41543">&#9670;&#160;</a></span>operator&quot;&quot;_KB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t operator&quot;&quot;_KB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga6b65aecdd2e2e777031cfb648c0dc779" name="ga6b65aecdd2e2e777031cfb648c0dc779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b65aecdd2e2e777031cfb648c0dc779">&#9670;&#160;</a></span>operator&quot;&quot;_MiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t operator&quot;&quot;_MiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga1931c0327c77d374f6c2fab637f6aa31" name="ga1931c0327c77d374f6c2fab637f6aa31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1931c0327c77d374f6c2fab637f6aa31">&#9670;&#160;</a></span>operator&quot;&quot;_MB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t operator&quot;&quot;_MB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga72a54307073160e72c67724e3c83a454" name="ga72a54307073160e72c67724e3c83a454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72a54307073160e72c67724e3c83a454">&#9670;&#160;</a></span>operator&quot;&quot;_GiB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t operator&quot;&quot;_GiB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<a id="ga97b4362f43a9bf8e339eae1b7ea6c57e" name="ga97b4362f43a9bf8e339eae1b7ea6c57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97b4362f43a9bf8e339eae1b7ea6c57e">&#9670;&#160;</a></span>operator&quot;&quot;_GB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t operator&quot;&quot;_GB </td>
          <td>(</td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Syntax sugar to express sizes with unit prefixes. </p>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The number of bytes <code>value</code> is in the given unit. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5cc824b77744b3bc5074b71c252b8f81" name="ga5cc824b77744b3bc5074b71c252b8f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc824b77744b3bc5074b71c252b8f81">&#9670;&#160;</a></span>cached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cached_arena</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls the caching of <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>. By default, deallocated blocks are put onto a cache, so they can be reused later; this tag value enable/disable it..<br  />
 This can be useful, e.g. if there will never be blocks available for deallocation. The (tiny) overhead for the cache can then be disabled. An example is <a class="el" href="classfoonathan_1_1memory_1_1memory__pool.html">memory_pool</a>. </p>

</div>
</div>
<a id="ga1b5ff9c47c6c768c7d5b9937f4df2434" name="ga1b5ff9c47c6c768c7d5b9937f4df2434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b5ff9c47c6c768c7d5b9937f4df2434">&#9670;&#160;</a></span>uncached_arena</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uncached_arena</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Controls the caching of <a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>. By default, deallocated blocks are put onto a cache, so they can be reused later; this tag value enable/disable it..<br  />
 This can be useful, e.g. if there will never be blocks available for deallocation. The (tiny) overhead for the cache can then be disabled. An example is <a class="el" href="classfoonathan_1_1memory_1_1memory__pool.html">memory_pool</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2
</small></address>
</body>
</html>
