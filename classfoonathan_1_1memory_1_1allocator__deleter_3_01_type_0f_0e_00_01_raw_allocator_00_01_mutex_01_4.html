<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: allocator_deleter&lt; Type[], RawAllocator, Mutex &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="group__memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_00_01_mutex_01_4.html">allocator_deleter&lt; Type[], RawAllocator, Mutex &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-methods">Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">allocator_deleter&lt; Type[], RawAllocator, Mutex &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__memory.html">memory</a> &#124; <a class="el" href="group__adapter.html">Adapters and Wrappers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Type, class RawAllocator, class Mutex&gt;<br />
class foonathan::memory::allocator_deleter&lt; Type[], RawAllocator, Mutex &gt;</h3>

<p>Specialization of <a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter.html">allocator_deleter</a> for array types. </p>
<p>Otherwise the same behavior. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4af7f2d45ae8a3174d142192395d18fc"><td class="memItemLeft" align="right" valign="top"><a id="a4af7f2d45ae8a3174d142192395d18fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = typename <a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt; RawAllocator, Mutex &gt;::allocator_type</td></tr>
<tr class="separator:a4af7f2d45ae8a3174d142192395d18fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memItemLeft" align="right" valign="top"><a id="a4a7a0dfdee0c83539ff9725f255c81ef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b> = Mutex</td></tr>
<tr class="separator:a4a7a0dfdee0c83539ff9725f255c81ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f70ef64d23e2379bacb63968e68b45"><td class="memItemLeft" align="right" valign="top"><a id="af0f70ef64d23e2379bacb63968e68b45"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = Type</td></tr>
<tr class="separator:af0f70ef64d23e2379bacb63968e68b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:a2e3e6af7a86aa848edea6009ad917499"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_00_01_mutex_01_4.html#a2e3e6af7a86aa848edea6009ad917499">allocator_deleter</a> () noexcept</td></tr>
<tr class="separator:a2e3e6af7a86aa848edea6009ad917499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1669a7b50ff8b771310f823bd8b41b16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_00_01_mutex_01_4.html#a1669a7b50ff8b771310f823bd8b41b16">allocator_deleter</a> (<a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt; RawAllocator, mutex &gt; alloc, std::size_t size) noexcept</td></tr>
<tr class="separator:a1669a7b50ff8b771310f823bd8b41b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126343d6121aa750c8cd4473cb0a8f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_00_01_mutex_01_4.html#a126343d6121aa750c8cd4473cb0a8f71">operator()</a> (value_type *pointer) noexcept</td></tr>
<tr class="separator:a126343d6121aa750c8cd4473cb0a8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aac6c1d2eeea76146f571978ed39e6c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_00_01_mutex_01_4.html#a9aac6c1d2eeea76146f571978ed39e6c">get_allocator</a> () const noexcept -&gt; decltype(std::declval&lt; <a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt; allocator_type, mutex &gt;&gt;().get_allocator())</td></tr>
<tr class="separator:a9aac6c1d2eeea76146f571978ed39e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689b4deadcfae0b08b85e60d177ac92"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter_3_01_type_0f_0e_00_01_raw_allocator_00_01_mutex_01_4.html#aa689b4deadcfae0b08b85e60d177ac92">array_size</a> () const noexcept</td></tr>
<tr class="separator:aa689b4deadcfae0b08b85e60d177ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructors</h2>
<a id="a2e3e6af7a86aa848edea6009ad917499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3e6af7a86aa848edea6009ad917499">&#9670;&nbsp;</a></span>allocator_deleter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter.html">allocator_deleter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Creates it without any associated allocator.</dt><dd>The deleter must not be used if that is the case. \notes This functions is useful if you have want to create an empty smart pointer without giving it an allocator. </dd></dl>

</div>
</div>
<a id="a1669a7b50ff8b771310f823bd8b41b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1669a7b50ff8b771310f823bd8b41b16">&#9670;&nbsp;</a></span>allocator_deleter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1allocator__deleter.html">allocator_deleter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt; RawAllocator, mutex &gt;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Creates it by passing it an \ref allocator_reference and the size of the array that will be deallocated.</dt><dd>It will store the reference to the allocator and uses the referenced allocator object for the deallocation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Functions</h2>
<a id="a126343d6121aa750c8cd4473cb0a8f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126343d6121aa750c8cd4473cb0a8f71">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operator() </td>
          <td>(</td>
          <td class="paramtype">value_type *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:\n Calls the destructors and deallocates the memory given to it.</dt><dd>Calls <code>deallocate_array</code>(pointer, size, sizeof(value_type), alignof(value_type)) on the referenced allocator object with the size given in the constructor for the deallocation. </dd></dl>
<dl class="section user"><dt>Requires:\n The deleter must not have been created by the default constructor. </dt><dd></dd></dl>

</div>
</div>
<a id="a9aac6c1d2eeea76146f571978ed39e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aac6c1d2eeea76146f571978ed39e6c">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(
                std::declval&lt;<a class="el" href="classfoonathan_1_1memory_1_1allocator__reference.html">allocator_reference</a>&lt;allocator_type, mutex&gt;&gt;().get_allocator())
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:\n The reference to the allocator.</dt><dd>It has the same type as the call to <a class="el" href="classfoonathan_1_1memory_1_1allocator__storage.html#ad0e22f6844a93ca183a896dc1e863a50">allocator_reference::get_allocator()</a>. </dd></dl>
<dl class="section user"><dt>Requires:\n The deleter must not be created by the default constructor. </dt><dd></dd></dl>

</div>
</div>
<a id="aa689b4deadcfae0b08b85e60d177ac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa689b4deadcfae0b08b85e60d177ac92">&#9670;&nbsp;</a></span>array_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t array_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:\n The size of the array that will be deallocated.</dt><dd>This is the same value as passed in the constructor, or <code>0</code> if it was created by the default constructor. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
