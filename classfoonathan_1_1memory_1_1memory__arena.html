<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: memory_arena&lt; BlockAllocator, Cached &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-static-methods">Static Functions</a> &#124;
<a href="#pub-methods">Member Functions</a>  </div>
  <div class="headertitle"><div class="title">memory_arena&lt; BlockAllocator, Cached &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__core.html">Core components</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class BlockAllocator, bool Cached&gt;<br />
class foonathan::memory::memory_arena&lt; BlockAllocator, Cached &gt;</div><p>A memory arena that manages huge memory blocks for a higher-level allocator. </p>
<p>Some allocators like <a class="el" href="classfoonathan_1_1memory_1_1memory__stack.html">memory_stack</a> work on huge memory blocks, this class manages them fro those allocators. It uses a <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> for the allocation of those blocks. The memory blocks in use are put onto a stack like structure, deallocation will pop from the top, so it is only possible to deallocate the last allocated block of the arena. By default, blocks are not really deallocated but stored in a cache. This can be disabled with the second template parameter, passing it <a class="el" href="group__core.html#ga1b5ff9c47c6c768c7d5b9937f4df2434">uncached_arena</a> (or <code>false</code>) disables it, <a class="el" href="group__core.html#ga5cc824b77744b3bc5074b71c252b8f81">cached_arena</a> (or <code>true</code>) enables it explicitly. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a76b5c635e11a3308bf0536d6bd4f4796" id="r_a76b5c635e11a3308bf0536d6bd4f4796"><td class="memItemLeft" align="right" valign="top"><a id="a76b5c635e11a3308bf0536d6bd4f4796" name="a76b5c635e11a3308bf0536d6bd4f4796"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a76b5c635e11a3308bf0536d6bd4f4796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d244da380a666c8d366ac781701539" id="r_a84d244da380a666c8d366ac781701539"><td class="memItemLeft" align="right" valign="top"><a id="a84d244da380a666c8d366ac781701539" name="a84d244da380a666c8d366ac781701539"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>is_cached</b></td></tr>
<tr class="separator:a84d244da380a666c8d366ac781701539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Functions</h2></td></tr>
<tr class="memitem:abb8ad90ad0272471cc42cf1bb3f50bc1" id="r_abb8ad90ad0272471cc42cf1bb3f50bc1"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb8ad90ad0272471cc42cf1bb3f50bc1">min_block_size</a> (std::size_t byte_size) noexcept</td></tr>
<tr class="separator:abb8ad90ad0272471cc42cf1bb3f50bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:adf5ac709c312e40ac3065ae352c63332" id="r_adf5ac709c312e40ac3065ae352c63332"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adf5ac709c312e40ac3065ae352c63332"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf5ac709c312e40ac3065ae352c63332">memory_arena</a> (std::size_t block_size, Args &amp;&amp;... args)</td></tr>
<tr class="separator:adf5ac709c312e40ac3065ae352c63332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145bd12ce94ddb628d37c7793c40cad2" id="r_a145bd12ce94ddb628d37c7793c40cad2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a145bd12ce94ddb628d37c7793c40cad2">~memory_arena</a> () noexcept</td></tr>
<tr class="separator:a145bd12ce94ddb628d37c7793c40cad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f99ac62de57d19c29608794fcf79ab" id="r_a36f99ac62de57d19c29608794fcf79ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36f99ac62de57d19c29608794fcf79ab">allocate_block</a> ()</td></tr>
<tr class="separator:a36f99ac62de57d19c29608794fcf79ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce3a91ec8795ec9cd29827aabd9c79" id="r_a48ce3a91ec8795ec9cd29827aabd9c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ce3a91ec8795ec9cd29827aabd9c79">current_block</a> () const noexcept</td></tr>
<tr class="separator:a48ce3a91ec8795ec9cd29827aabd9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a97d64ca305f9ef9e8b43c4ffc86511" id="r_a7a97d64ca305f9ef9e8b43c4ffc86511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a97d64ca305f9ef9e8b43c4ffc86511">deallocate_block</a> () noexcept</td></tr>
<tr class="separator:a7a97d64ca305f9ef9e8b43c4ffc86511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63703ee0b77d33c71c8b390f410884ff" id="r_a63703ee0b77d33c71c8b390f410884ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63703ee0b77d33c71c8b390f410884ff">owns</a> (const void *ptr) const noexcept</td></tr>
<tr class="separator:a63703ee0b77d33c71c8b390f410884ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4af5032d71179d3abf04db463f791" id="r_ad9e4af5032d71179d3abf04db463f791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit</a> () noexcept</td></tr>
<tr class="separator:ad9e4af5032d71179d3abf04db463f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab920f7734a1bb13ea973cf45de7a0577" id="r_ab920f7734a1bb13ea973cf45de7a0577"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab920f7734a1bb13ea973cf45de7a0577">capacity</a> () const noexcept</td></tr>
<tr class="separator:ab920f7734a1bb13ea973cf45de7a0577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2c9beae518e816850d585b1a750cdb" id="r_abc2c9beae518e816850d585b1a750cdb"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc2c9beae518e816850d585b1a750cdb">cache_size</a> () const noexcept</td></tr>
<tr class="separator:abc2c9beae518e816850d585b1a750cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7434932a5e343fc55ba86506da43c7" id="r_a4f7434932a5e343fc55ba86506da43c7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f7434932a5e343fc55ba86506da43c7">size</a> () const noexcept</td></tr>
<tr class="separator:a4f7434932a5e343fc55ba86506da43c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c71dfd2e8d552b753c7d16186b83da" id="r_ad2c71dfd2e8d552b753c7d16186b83da"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2c71dfd2e8d552b753c7d16186b83da">next_block_size</a> () const noexcept</td></tr>
<tr class="separator:ad2c71dfd2e8d552b753c7d16186b83da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b7646357aaf9599f36aa528674aaa" id="r_acf4b7646357aaf9599f36aa528674aaa"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4b7646357aaf9599f36aa528674aaa">get_allocator</a> () noexcept</td></tr>
<tr class="separator:acf4b7646357aaf9599f36aa528674aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3fa237597c98305c7ec7cebfd68ec98f" id="r_a3fa237597c98305c7ec7cebfd68ec98f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa237597c98305c7ec7cebfd68ec98f">memory_arena</a> (<a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a3fa237597c98305c7ec7cebfd68ec98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec40dd19fecd3a5392412a2dbc59f84" id="r_a3ec40dd19fecd3a5392412a2dbc59f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ec40dd19fecd3a5392412a2dbc59f84">operator=</a> (<a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a3ec40dd19fecd3a5392412a2dbc59f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructors</h2>
<a id="adf5ac709c312e40ac3065ae352c63332" name="adf5ac709c312e40ac3065ae352c63332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5ac709c312e40ac3065ae352c63332">&#9670;&#160;</a></span>memory_arena() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>block_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Creates it by giving it the size and other arguments for the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. It forwards these arguments to its constructor. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>block_size</code> must be greater than <code>min_block_size(0)</code> and other requirements depending on the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </dd></dl>
<dl class="section user"><dt><em>Throws:</em></dt><dd>Anything thrown by the constructor of the <code>BlockAllocator</code>. </dd></dl>

</div>
</div>
<a id="a145bd12ce94ddb628d37c7793c40cad2" name="a145bd12ce94ddb628d37c7793c40cad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145bd12ce94ddb628d37c7793c40cad2">&#9670;&#160;</a></span>~memory_arena()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Deallocates all memory blocks that where requested back to the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </dd></dl>

</div>
</div>
<a id="a3fa237597c98305c7ec7cebfd68ec98f" name="a3fa237597c98305c7ec7cebfd68ec98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa237597c98305c7ec7cebfd68ec98f">&#9670;&#160;</a></span>memory_arena() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>&lt; BlockAllocator, Cached &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Moves the arena. The new arena takes ownership over all the memory blocks from the other arena object, which is empty after that. This does not invalidate any memory blocks. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Functions</h2>
<a id="abb8ad90ad0272471cc42cf1bb3f50bc1" name="abb8ad90ad0272471cc42cf1bb3f50bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8ad90ad0272471cc42cf1bb3f50bc1">&#9670;&#160;</a></span>min_block_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t min_block_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>byte_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The minimum block size required for an arena containing the given amount of memory. If an arena is created with the result of <code>min_block_size(n)</code>, the resulting capacity will be exactly <code>n</code>. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd><code>byte_size</code> must be a positive number. </dd></dl>

</div>
</div>
<a id="a3ec40dd19fecd3a5392412a2dbc59f84" name="a3ec40dd19fecd3a5392412a2dbc59f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec40dd19fecd3a5392412a2dbc59f84">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfoonathan_1_1memory_1_1memory__arena.html">memory_arena</a>&lt; BlockAllocator, Cached &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Moves the arena. The new arena takes ownership over all the memory blocks from the other arena object, which is empty after that. This does not invalidate any memory blocks. </dd></dl>

</div>
</div>
<a id="a36f99ac62de57d19c29608794fcf79ab" name="a36f99ac62de57d19c29608794fcf79ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f99ac62de57d19c29608794fcf79ab">&#9670;&#160;</a></span>allocate_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a> allocate_block </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Allocates a new memory block. It first uses a cache of previously deallocated blocks, if caching is enabled, if it is empty, allocates a new one. </dd></dl>
<dl class="section user"><dt><em>Returns:</em></dt><dd>The new <a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a>. </dd></dl>
<dl class="section user"><dt><em>Throws:</em></dt><dd>Anything thrown by the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> allocation function. </dd></dl>

</div>
</div>
<a id="a48ce3a91ec8795ec9cd29827aabd9c79" name="a48ce3a91ec8795ec9cd29827aabd9c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ce3a91ec8795ec9cd29827aabd9c79">&#9670;&#160;</a></span>current_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfoonathan_1_1memory_1_1memory__block.html">memory_block</a> current_block </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The current memory block. This is the memory block that will be deallocated by the next call to <a class="el" href="#a7a97d64ca305f9ef9e8b43c4ffc86511">deallocate_block()</a>. </dd></dl>

</div>
</div>
<a id="a7a97d64ca305f9ef9e8b43c4ffc86511" name="a7a97d64ca305f9ef9e8b43c4ffc86511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a97d64ca305f9ef9e8b43c4ffc86511">&#9670;&#160;</a></span>deallocate_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_block </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Deallocates the current memory block. The current memory block is the block on top of the stack of blocks. If caching is enabled, it does not really deallocate it but puts it onto a cache for later use, use <a class="el" href="#ad9e4af5032d71179d3abf04db463f791">shrink_to_fit()</a> to purge that cache. </dd></dl>

</div>
</div>
<a id="a63703ee0b77d33c71c8b390f410884ff" name="a63703ee0b77d33c71c8b390f410884ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63703ee0b77d33c71c8b390f410884ff">&#9670;&#160;</a></span>owns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool owns </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>If <code>ptr</code> is in memory owned by the arena. </dd></dl>

</div>
</div>
<a id="ad9e4af5032d71179d3abf04db463f791" name="ad9e4af5032d71179d3abf04db463f791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e4af5032d71179d3abf04db463f791">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Effects:</em></dt><dd>Purges the cache of unused memory blocks by returning them. The memory blocks will be deallocated in reversed order of allocation. Does nothing if caching is disabled. </dd></dl>

</div>
</div>
<a id="ab920f7734a1bb13ea973cf45de7a0577" name="ab920f7734a1bb13ea973cf45de7a0577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab920f7734a1bb13ea973cf45de7a0577">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The capacity of the arena, i.e. how many blocks are used and cached. </dd></dl>

</div>
</div>
<a id="abc2c9beae518e816850d585b1a750cdb" name="abc2c9beae518e816850d585b1a750cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2c9beae518e816850d585b1a750cdb">&#9670;&#160;</a></span>cache_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cache_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The size of the cache, i.e. how many blocks can be allocated without allocation. </dd></dl>

</div>
</div>
<a id="a4f7434932a5e343fc55ba86506da43c7" name="a4f7434932a5e343fc55ba86506da43c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7434932a5e343fc55ba86506da43c7">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The size of the arena, i.e. how many blocks are in use. It is always smaller or equal to the <a class="el" href="#ab920f7734a1bb13ea973cf45de7a0577">capacity()</a>. </dd></dl>

</div>
</div>
<a id="ad2c71dfd2e8d552b753c7d16186b83da" name="ad2c71dfd2e8d552b753c7d16186b83da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c71dfd2e8d552b753c7d16186b83da">&#9670;&#160;</a></span>next_block_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t next_block_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>The size of the next memory block, i.e. of the next call to <a class="el" href="#a36f99ac62de57d19c29608794fcf79ab">allocate_block()</a>. If there are blocks in the cache, returns size of the next one. Otherwise forwards to the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> and subtracts an implementation offset. </dd></dl>

</div>
</div>
<a id="acf4b7646357aaf9599f36aa528674aaa" name="acf4b7646357aaf9599f36aa528674aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4b7646357aaf9599f36aa528674aaa">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BlockAllocator, bool Cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type &amp; get_allocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt><em>Returns:</em></dt><dd>A reference of the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> object. </dd></dl>
<dl class="section user"><dt><em>Requires:</em></dt><dd>It is undefined behavior to move this allocator out into another object. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.13.2
</small></address>
</body>
</html>
