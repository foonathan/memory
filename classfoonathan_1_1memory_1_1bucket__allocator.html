<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>memory: bucket_allocator&lt; PoolType, ImplAllocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
        <li><a href="index.html">Main Page</a></li>
        <li><a href="md_doc_tutorial.html">Tutorial</a></li>
        <li><a href="namespacefoonathan_1_1memory.html">Index</a></li>
        <li><a href="files.html">Files</a></li>
    </ul>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefoonathan.html">foonathan</a></li><li class="navelem"><a class="el" href="namespacefoonathan_1_1memory.html">memory</a></li><li class="navelem"><a class="el" href="classfoonathan_1_1memory_1_1bucket__allocator.html">bucket_allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Typedefs</a> &#124;
<a href="#pub-methods">Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">bucket_allocator&lt; PoolType, ImplAllocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__allocator.html">Allocator implementations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class PoolType = node_pool, class ImplAllocator = default_allocator&gt;<br />
class foonathan::memory::bucket_allocator&lt; PoolType, ImplAllocator &gt;</h3>

<p>An alias for <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html">memory_pool_collection</a> using the <a class="el" href="structfoonathan_1_1memory_1_1identity__buckets.html">identity_buckets</a> policy and a <code>PoolType</code> defaulting to <a class="el" href="structfoonathan_1_1memory_1_1node__pool.html">node_pool</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7fd26a8539389ffa2a4b1d1a7b6b839c"><td class="memItemLeft" align="right" valign="top"><a id="a7fd26a8539389ffa2a4b1d1a7b6b839c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = <a class="el" href="group__core.html#gaf1ce941b1306a592d4ebba1167fd98aa">make_block_allocator_t</a>&lt; <a class="el" href="group__allocator.html#ga10acce2d854fc42fea7306e511d9cd10">default_allocator</a> &gt;</td></tr>
<tr class="separator:a7fd26a8539389ffa2a4b1d1a7b6b839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a387e63de9c0ba78a5f77675ff8eed"><td class="memItemLeft" align="right" valign="top"><a id="a57a387e63de9c0ba78a5f77675ff8eed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pool_type</b> = <a class="el" href="structfoonathan_1_1memory_1_1node__pool.html">node_pool</a></td></tr>
<tr class="separator:a57a387e63de9c0ba78a5f77675ff8eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d55454c8b83335e6b2d4704f67d35b"><td class="memItemLeft" align="right" valign="top"><a id="a61d55454c8b83335e6b2d4704f67d35b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_distribution</b> = <a class="el" href="structfoonathan_1_1memory_1_1identity__buckets.html">identity_buckets</a></td></tr>
<tr class="separator:a61d55454c8b83335e6b2d4704f67d35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Member Functions</h2></td></tr>
<tr class="memitem:acdb51b626fa21c10ea5e7ff7e0f767b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acdb51b626fa21c10ea5e7ff7e0f767b7">allocate_node</a> (std::size_t node_size)</td></tr>
<tr class="separator:acdb51b626fa21c10ea5e7ff7e0f767b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d803fa2333bca801c80f1dd49b1919b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a9d803fa2333bca801c80f1dd49b1919b">try_allocate_node</a> (std::size_t node_size) noexcept</td></tr>
<tr class="separator:a9d803fa2333bca801c80f1dd49b1919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720a69b26898e57f8ae02719ef396126"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a720a69b26898e57f8ae02719ef396126">allocate_array</a> (std::size_t count, std::size_t node_size)</td></tr>
<tr class="separator:a720a69b26898e57f8ae02719ef396126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e5dcf97500c79bde4841307f3800bd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a49e5dcf97500c79bde4841307f3800bd">try_allocate_array</a> (std::size_t count, std::size_t node_size) noexcept</td></tr>
<tr class="separator:a49e5dcf97500c79bde4841307f3800bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea27e87dff3fd937c27956280ffa723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#abea27e87dff3fd937c27956280ffa723">deallocate_node</a> (void *ptr, std::size_t node_size) noexcept</td></tr>
<tr class="separator:abea27e87dff3fd937c27956280ffa723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aa533ff359590cafe8029be35e7b58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a45aa533ff359590cafe8029be35e7b58">try_deallocate_node</a> (void *ptr, std::size_t node_size) noexcept</td></tr>
<tr class="separator:a45aa533ff359590cafe8029be35e7b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8b16f2361fbc3bc38405142edcad37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#ade8b16f2361fbc3bc38405142edcad37">deallocate_array</a> (void *ptr, std::size_t count, std::size_t node_size) noexcept</td></tr>
<tr class="separator:ade8b16f2361fbc3bc38405142edcad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5b9ad4ae5cbbcb262f329ab902badb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a0e5b9ad4ae5cbbcb262f329ab902badb">try_deallocate_array</a> (void *ptr, std::size_t count, std::size_t node_size) noexcept</td></tr>
<tr class="separator:a0e5b9ad4ae5cbbcb262f329ab902badb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053249e1f3314b2769617d17f3c0aef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a053249e1f3314b2769617d17f3c0aef3">reserve</a> (std::size_t node_size, std::size_t capacity)</td></tr>
<tr class="separator:a053249e1f3314b2769617d17f3c0aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa832c9a7c293c443582bce418e6ff7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acaa832c9a7c293c443582bce418e6ff7">max_node_size</a> () const noexcept</td></tr>
<tr class="separator:acaa832c9a7c293c443582bce418e6ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a5ee2f65b4927734c4bb5f06c8aec3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#ab8a5ee2f65b4927734c4bb5f06c8aec3">pool_capacity_left</a> (std::size_t node_size) const noexcept</td></tr>
<tr class="separator:ab8a5ee2f65b4927734c4bb5f06c8aec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da77ca5a46e5e3088d6c0637b52af7"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a97da77ca5a46e5e3088d6c0637b52af7">capacity_left</a> () const noexcept</td></tr>
<tr class="separator:a97da77ca5a46e5e3088d6c0637b52af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fe037332aabd13253517d22394da73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#af4fe037332aabd13253517d22394da73">next_capacity</a> () const noexcept</td></tr>
<tr class="separator:af4fe037332aabd13253517d22394da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae445687ecb4a037b542ede5c6f48ac"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a3ae445687ecb4a037b542ede5c6f48ac">get_allocator</a> () noexcept</td></tr>
<tr class="separator:a3ae445687ecb4a037b542ede5c6f48ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Functions</h2>
<a id="acdb51b626fa21c10ea5e7ff7e0f767b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb51b626fa21c10ea5e7ff7e0f767b7">&#9670;&nbsp;</a></span>allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Allocates a <a href="md_doc_concepts.html#concept_node">node</a> of given size. It first finds the appropriate free list as defined in the <code>BucketDistribution</code>. If it is empty, it will use an implementation defined amount of memory from the arena and inserts it in it. If the arena is empty too, it will request a new memory block from the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> of size <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#af4fe037332aabd13253517d22394da73">next_capacity()</a> and puts part of it onto this free list. Then it removes a node from it. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd>A <a href="md_doc_concepts.html#concept_node">node</a> of given size suitable aligned, i.e. suitable for any type where <code>sizeof(T) &lt; node_size</code>. </dd></dl>
<dl class="section user"><dt>Throws:</dt><dd>Anything thrown by the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> if a growth is needed or a <a class="el" href="classfoonathan_1_1memory_1_1bad__node__size.html">bad_node_size</a> exception if the node size is too big. </dd></dl>

</div>
</div>
<a id="a9d803fa2333bca801c80f1dd49b1919b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d803fa2333bca801c80f1dd49b1919b">&#9670;&nbsp;</a></span>try_allocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate_node </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Allocates a <a href="md_doc_concepts.html#concept_node">node</a> of given size. It is similar to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acdb51b626fa21c10ea5e7ff7e0f767b7">allocate_node()</a> but will return <code>nullptr</code> on any failure, instead of growing the arnea and possibly throwing. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd>A <a href="md_doc_concepts.html#concept_node">node</a> of given size suitable aligned or <code>nullptr</code> in case of failure. </dd></dl>

</div>
</div>
<a id="a720a69b26898e57f8ae02719ef396126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720a69b26898e57f8ae02719ef396126">&#9670;&nbsp;</a></span>allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Allocates an <a href="md_doc_concepts.html#concept_array">array</a> of nodes by searching for <code>n</code> continuous nodes on the appropriate free list and removing them. Depending on the <code>PoolType</code> this can be a slow operation or not allowed at all. This can sometimes lead to a growth on the free list, even if technically there is enough continuous memory on the free list. Otherwise has the same behavior as <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acdb51b626fa21c10ea5e7ff7e0f767b7">allocate_node()</a>. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd>An array of <code>n</code> nodes of size <code>node_size</code> suitable aligned. </dd></dl>
<dl class="section user"><dt>Throws:</dt><dd>Anything thrown by the used <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>'s allocation function if a growth is needed, or a <a class="el" href="classfoonathan_1_1memory_1_1bad__allocation__size.html">bad_allocation_size</a> exception. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd><code>count</code> must be valid <a href="md_doc_concepts.html#concept_array">array count</a> and <code>node_size</code> must be valid <a href="md_doc_concepts.html#concept_node">node size</a>. </dd></dl>

</div>
</div>
<a id="a49e5dcf97500c79bde4841307f3800bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e5dcf97500c79bde4841307f3800bd">&#9670;&nbsp;</a></span>try_allocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate_array </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Allocates a <a href="md_doc_concepts.html#concept_array">array</a> of given size. It is similar to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acdb51b626fa21c10ea5e7ff7e0f767b7">allocate_node()</a> but will return <code>nullptr</code> on any failure, instead of growing the arnea and possibly throwing. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd>A <a href="md_doc_concepts.html#concept_array">array</a> of given size suitable aligned or <code>nullptr</code> in case of failure. </dd></dl>

</div>
</div>
<a id="abea27e87dff3fd937c27956280ffa723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea27e87dff3fd937c27956280ffa723">&#9670;&nbsp;</a></span>deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Deallocates a <a href="md_doc_concepts.html#concept_node">node</a> by putting it back onto the appropriate free list. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd><code>ptr</code> must be a result from a previous call to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acdb51b626fa21c10ea5e7ff7e0f767b7">allocate_node()</a> with the same size on the same free list, i.e. either this allocator object or a new object created by moving this to it. </dd></dl>

</div>
</div>
<a id="a45aa533ff359590cafe8029be35e7b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aa533ff359590cafe8029be35e7b58">&#9670;&nbsp;</a></span>try_deallocate_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Deallocates a <a href="md_doc_concepts.html#concept_node">node</a> similar to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#abea27e87dff3fd937c27956280ffa723">deallocate_node()</a>. But it checks if it can deallocate this memory. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd><code>true</code> if the node could be deallocated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ade8b16f2361fbc3bc38405142edcad37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8b16f2361fbc3bc38405142edcad37">&#9670;&nbsp;</a></span>deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Deallocates an <a href="md_doc_concepts.html#concept_array">array</a> by putting it back onto the free list. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd><code>ptr</code> must be a result from a previous call to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a720a69b26898e57f8ae02719ef396126">allocate_array()</a> with the same sizes on the same free list, i.e. either this allocator object or a new object created by moving this to it. </dd></dl>

</div>
</div>
<a id="a0e5b9ad4ae5cbbcb262f329ab902badb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5b9ad4ae5cbbcb262f329ab902badb">&#9670;&nbsp;</a></span>try_deallocate_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_deallocate_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Deallocates a <a href="md_doc_concepts.html#concept_array">array</a> similar to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#ade8b16f2361fbc3bc38405142edcad37">deallocate_array()</a>. But it checks if it can deallocate this memory. </dd></dl>
<dl class="section user"><dt>Returns:</dt><dd><code>true</code> if the array could be deallocated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a053249e1f3314b2769617d17f3c0aef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053249e1f3314b2769617d17f3c0aef3">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Effects:</dt><dd>Inserts more memory on the free list for nodes of given size. It will try to put <code>capacity_left</code> bytes from the arena onto the free list defined over the <code>BucketDistribution</code>, if the arena is empty, a new memory block is requested from the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> and it will be used. </dd></dl>
<dl class="section user"><dt>Throws:</dt><dd>Anything thrown by the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> if a growth is needed. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd><code>node_size</code> must be valid <a href="md_doc_concepts.html#concept_node">node size</a> less than or equal to <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#acaa832c9a7c293c443582bce418e6ff7">max_node_size()</a>, <code>capacity_left</code> must be less than <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#af4fe037332aabd13253517d22394da73">next_capacity()</a>. </dd></dl>

</div>
</div>
<a id="acaa832c9a7c293c443582bce418e6ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa832c9a7c293c443582bce418e6ff7">&#9670;&nbsp;</a></span>max_node_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t max_node_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>The maximum node size for which is a free list. This is the value passed to it in the constructor. </dd></dl>

</div>
</div>
<a id="ab8a5ee2f65b4927734c4bb5f06c8aec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a5ee2f65b4927734c4bb5f06c8aec3">&#9670;&nbsp;</a></span>pool_capacity_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pool_capacity_left </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>node_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>The amount of nodes available in the free list for nodes of given size as defined over the <code>BucketDistribution</code>. This is the number of nodes that can be allocated without the free list requesting more memory from the arena. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Array allocations may lead to a growth even if the capacity_left is big enough. </dd></dl>

</div>
</div>
<a id="a97da77ca5a46e5e3088d6c0637b52af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97da77ca5a46e5e3088d6c0637b52af7">&#9670;&nbsp;</a></span>capacity_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t capacity_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>The amount of memory available in the arena not inside the free lists. This is the number of bytes that can be inserted into the free lists without requesting more memory from the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Array allocations may lead to a growth even if the capacity is big enough. </dd></dl>

</div>
</div>
<a id="af4fe037332aabd13253517d22394da73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fe037332aabd13253517d22394da73">&#9670;&nbsp;</a></span>next_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t next_capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>The size of the next memory block after <a class="el" href="classfoonathan_1_1memory_1_1memory__pool__collection.html#a97da77ca5a46e5e3088d6c0637b52af7">capacity_left()</a> arena grows. This is the amount of memory that can be distributed in the pools. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the <code>PoolType</code> is <a class="el" href="structfoonathan_1_1memory_1_1small__node__pool.html">small_node_pool</a>, the exact usable memory is lower than that. </dd></dl>

</div>
</div>
<a id="a3ae445687ecb4a037b542ede5c6f48ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae445687ecb4a037b542ede5c6f48ac">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type&amp; get_allocator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section user"><dt>Returns:</dt><dd>A reference to the <a href="md_doc_concepts.html#concept_blockallocator">BlockAllocator</a> used for managing the arena. </dd></dl>
<dl class="section user"><dt>Requires:</dt><dd>It is undefined behavior to move this allocator out into another object. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.16-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
